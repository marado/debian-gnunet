This is gnunet.info, produced by makeinfo version 4.8 from gnunet.texi.

   Copyright (C) 2001-2019 GNUnet e.V.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License".

   A copy of the license is also available from the Free Software
Foundation Web site at `http://www.gnu.org/licenses/fdl.html'.

   Alternately, this document is also available under the General
Public License, version 3 or later, as published by the Free Software
Foundation.  A copy of the license is included in the section entitled
"GNU General Public License".

   A copy of the license is also available from the Free Software
Foundation Web site at `http://www.gnu.org/licenses/gpl.html'.

INFO-DIR-SECTION Networking
START-INFO-DIR-ENTRY
* GNUnet: (gnunet).       Framework for secure peer-to-peer networking
END-INFO-DIR-ENTRY


File: gnunet.info,  Node: Top,  Next: Preface,  Up: (dir)

Introduction
************

This document is the Reference Manual for GNUnet version 0.12.0.

* Menu:


* Preface::                         Preface
* Philosophy::                      About GNUnet
* Key Concepts::                    Key concepts of GNUnet
* Installing GNUnet::               Installing GNUnet
* Using GNUnet::                    Using GNUnet
* GNUnet Contributors Handbook::    Contributing to GNUnet
* GNUnet Developer Handbook::       Developing GNUnet
* GNU Free Documentation License::  The license of this manual
* GNU General Public License::
* GNU Affero General Public License::
* Concept Index::                   Concepts
* Programming Index::               Data types, functions, and variables

 --- The Detailed Node Listing ---

Preface

* About this book
* Contributing to this book
* Introduction
* Typography::

Philosophy

* Design Principles::
* Privacy and Anonymity::
* Practicality::

Key Concepts

* Authentication::
* Accounting to Encourage Resource Sharing::
* Confidentiality::
* Anonymity::
* Deniability::
* Peer Identities::
* Zones in the GNU Name System (GNS Zones)::
* Egos::
* Backup of Identities and Egos::
* Revocation::

Installing GNUnet
* Installing dependencies::
* Getting the Source Code::
* Create user and groups for the system services::
* Preparing and Compiling the Source Code::
* Installation::
* Checking the Installation::
* The graphical configuration interface::
* Config Leftovers::

Using GNUnet

* Start and stop GNUnet::
* First steps - Using the GNU Name System::
* First steps - Using GNUnet Conversation::
* First steps - Using the GNUnet VPN::
* File-sharing::
* The GNU Name System::
* reclaimID Identity Provider::
* Using the Virtual Public Network::

GNUnet Contributors Handbook

* Contributing to GNUnet::
* Licenses of contributions::
* Copyright Assignment::
* Contributing to the Reference Manual::
* Contributing testcases::

GNUnet Developer Handbook

* Developer Introduction::
* Internal dependencies::
* Code overview::
* System Architecture::
* Subsystem stability::
* Naming conventions and coding style guide::
* Build-system::
* Developing extensions for GNUnet using the gnunet-ext template::
* Writing testcases::
* Building GNUnet and its dependencies::
* TESTING library::
* Performance regression analysis with Gauger::
* TESTBED Subsystem::
* libgnunetutil::
* Automatic Restart Manager (ARM)::
* TRANSPORT Subsystem::
* NAT library::
* Distance-Vector plugin::
* SMTP plugin::
* Bluetooth plugin::
* WLAN plugin::
* ATS Subsystem::
* CORE Subsystem::
* CADET Subsystem::
* NSE Subsystem::
* HOSTLIST Subsystem::
* IDENTITY Subsystem::
* NAMESTORE Subsystem::
* PEERINFO Subsystem::
* PEERSTORE Subsystem::
* SET Subsystem::
* STATISTICS Subsystem::
* Distributed Hash Table (DHT)::
* GNU Name System (GNS)::
* GNS Namecache::
* REVOCATION Subsystem::
* File-sharing (FS) Subsystem::
* REGEX Subsystem::


File: gnunet.info,  Node: Preface,  Next: Philosophy,  Prev: Top,  Up: Top

1 Preface
*********

This collection of manuals describes GNUnet, a framework for secure
peer-to-peer networking with the high-level goal to provide a strong
foundation for a global, distributed network that provides security and
privacy.  GNUnet in that sense aims to replace the current Internet
protocol stack.  Along with an application for secure publication of
files, it has grown to include all kinds of basic applications for the
foundation of a new Internet.

* Menu:

* About this book::
* Contributing to this book::
* Introduction::
* Project governance::
* Typography::


File: gnunet.info,  Node: About this book,  Next: Contributing to this book,  Up: Preface

1.1 About this book
===================

The books (described as "book" or "books" in the following) bundled as
the "GNUnet Reference Manual" are based on the historic work of all
contributors to previous documentation of GNUnet.  It is our hope that
the content is described in a way that does not require any academic
background, although some concepts will require further reading.

   Our (long-term) goal with these books is to keep them
self-contained. If you see references to Wikipedia and other external
sources (except for our academic papers) it means that we are working
on a solution to describe the explanations found there which fits our
use-case and licensing.

   Previously the documentation was contained in Drupal books, on the
old website. This format was considered unmaintainable for the future,
so Texinfo was chosen. You might find old and very old sections in here
in addition to more recent content. It took a long time to finish the
move to Texinfo (from Drupal to LaTeX to wrong Texinfo output dump to
good Texinfo) and only recently (late 2018, early 2019) content
checking started. We apologize to the reader for any inconvenience and
hope you apply logic where bad advice from 10 years ago can be found
(pipe to sudo to install software is one example). Patches
(contributions) to this documentation are more than welcome!

   The first chapter ("Preface") as well as the second chapter
("Philosophy") give an introduction to GNUnet as a project, what GNUnet
tries to achieve. "Key Concepts" explains the key concepts in GNUnet.
These three chapters are the most complete in the documentation.  They
are followed by chapters which explain specific parts of GNUnet (and
need more work): "Installing GNUnet", "GNUnet Contributors Handbook" and
"GNUnet Developer Handbook".


File: gnunet.info,  Node: Contributing to this book,  Next: Introduction,  Prev: About this book,  Up: Preface

1.2 Contributing to this book
=============================

The GNUnet Reference Manual is a collective work produced by various
people throughout the years.

   The version you are reading is derived from many individual efforts
hosted on one of our old websites.  In the end it was considered to be
impractical to read by those who required the information.  With the
conversion to Texinfo -- the version you are reading right now -- we
hope to address this in the longterm.  Texinfo is the documentation
language of the GNU project.

   While it can be intimidating at first and look scary or complicated,
it is just another way to express text format instructions.

   We encourage you to take this opportunity and learn about Texinfo,
learn about GNUnet, and one word at a time we will arrive at a book
which explains GNUnet in the least complicated way to you.

   Even when you don't want to or can't learn Texinfo, you can
contribute.  Send us an Email or join our IRC chat room on freenode and
talk with us about the documentation (the prefered way to reach out is
the mailinglist, since you can communicate with us without waiting on
someone in the chatroom).  One way or another you can help shape the
understanding of GNUnet without the ability to read and understand its
sourcecode.


File: gnunet.info,  Node: Introduction,  Next: Project governance,  Prev: Contributing to this book,  Up: Preface

1.3 Introduction
================

GNUnet in its current version is the result of almost 20 years of work
from many contributors.  So far, most contributions were made by
volunteers or people paid to do fundamental research.  At this stage,
GNUnet remains an experimental system where significant parts of the
software lack a reasonable degree of professionalism in its
implementation.  Furthermore, we are aware of a significant number of
existing bugs and critical design flaws, as some unfortunate early
design decisions remain to be rectified.  There are still known open
problems; GNUnet remains an active research project.

   The project was started in 2001 when some initial ideas for improving
Freenet's file-sharing turned out to be too radical to be easily
realized within the scope of the existing Freenet project.  We lost our
first contributor on 11.9.2001 as the contributor realized that privacy
may help terrorists.  The rest of the team concluded that it was now
even more important to fight for civil liberties.  The first release
was called "GNet" - already with the name GNUnet in mind, but without
the blessing of GNU we did not dare to call it GNUnet immediately.  A
few months after the first release we contacted the GNU project,
happily agreed to their governance model and became an official GNU
package.

   Within the first year, we created GNU libextractor
(https://gnu.org/s/libextractor), a helper library for meta data
extraction which has been used by a few other projects as well.  2003
saw the emergence of pluggable transports, the ability for GNUnet to
use different mechanisms for communication, starting with TCP, UDP and
SMTP (support for the latter was later dropped due to a lack of
maintenance).  In 2005, the project first started to evolve beyond the
original file-sharing application with a first simple P2P chat.  In
2007, we created GNU libmicrohttpd (https://gnu.org/s/libmicrohttpd) to
support a pluggable transport based on HTTP.  In 2009, the architecture
was radically modularized into the multi-process system that exists
today.  Coincidentally, the first version of the ARM service (ARM:
Automatic Restart Manager) was implemented a day before systemd was
announced.  From 2009 to 2014 work progressed rapidly thanks to a
significant research grant from the Deutsche Forschungsgesellschaft.
This resulted in particular in the creation of the R5N DHT, CADET, ATS
and the GNU Name System.  In 2010, GNUnet was selected as the basis for
the secushare (https://secushare.org) online social network, resulting
in a significant growth of the core team.  In 2013, we launched GNU
Taler (https://taler.net) to address the challenge of convenient and
privacy-preserving online payments.  In 2015, the pretty Easy privacy
(https://pep.foundation/) (pEp) project announced that they will use
GNUnet as the technology for their meta-data protection layer,
ultimately resulting in GNUnet e.V.  entering into a formal long-term
collaboration with the pEp Foundation.  In 2016, Taler Systems SA, a
first startup using GNUnet technology, was founded with support from
the community.

   GNUnet is not merely a technical project, but also a political
mission: like the GNU project as a whole, we are writing software to
achieve political goals with a focus on the human right of
informational self-determination.  Putting users in control of their
computing has been the core driver of the GNU project. With GNUnet we
are focusing on informational self-determination for collaborative
computing and communication over networks.

   The Internet is shaped as much by code and protocols as it is by its
associated political processes (IETF, ICANN, IEEE, etc.).  Similarly
its flaws are not limited to the protocol design.  Thus, technical
excellence by itself will not suffice to create a better network. We
also need to build a community that is wise, humble and has a sense of
humor to achieve our goal to create a technical foundation for a
society we would like to live in.


File: gnunet.info,  Node: Project governance,  Next: Typography,  Prev: Introduction,  Up: Preface

1.4 Project governance
======================

GNUnet, like the GNU project and many other free software projects,
follows the governance model of a benevolent dictator.  This means that
ultimately, the GNU project appoints the GNU maintainer and can
overrule decisions made by the GNUnet maintainer. Similarly, the GNUnet
maintainer can overrule any decisions made by individual developers.
Still, in practice neither has happened in the last 20 years for
GNUnet, and we hope to keep it that way.

   The GNUnet project is supported by GNUnet e.V., a German association
where any developer can become a member.  GNUnet e.V. serves as a legal
entity to hold the copyrights to GNUnet.  GNUnet e.V. may also choose
to pay for project resources, and can collect donations.  GNUnet e.V.
may also choose to adjust the license of the software (with the
constraint that it has to remain free software).  In 2018 we switched
from GPL3 to AGPL3, in practice these changes do not happen very often.


File: gnunet.info,  Node: Typography,  Prev: Project governance,  Up: Preface

1.5 Typography
==============

When giving examples for commands, shell prompts are used to show if the
command should/can be issued as root, or if "normal" user privileges are
sufficient. We use a `#' for root's shell prompt, a `%' for users'
shell prompt, assuming they use the C-shell or tcsh and a `$' for
bourne shell and derivatives.


File: gnunet.info,  Node: Philosophy,  Next: Key Concepts,  Prev: Preface,  Up: Top

2 Philosophy
************

The primary goal of the GNUnet project is to provide a reliable, open,
non-discriminating and censorship-resistant system for information
exchange. We value free speech above state interests and intellectual
monopoly. GNUnet's long-term goal is to serve as a development platform
for the next generation of Internet protocols.

   GNUnet is an anarchistic network. Participants are encouraged to
contribute at least as much resources (storage, bandwidth) to the
network as they consume, so that their participation does not have a
negative impact on other users.

* Menu:

* Design Principles::
* Privacy and Anonymity::
* Practicality::


File: gnunet.info,  Node: Design Principles,  Next: Privacy and Anonymity,  Up: Philosophy

2.1 Design Principles
=====================

These are the GNUnet design principles, in order of importance:

   * GNUnet must be implemented as Free Software
     (https://www.gnu.org/philosophy/free-sw.html) -- This means that
     you have the four essential freedoms: to run the program, to study
     and change the program in source code form, to redistribute exact
     copies, and to distribute modified versions.
     (`https://www.gnu.org/philosophy/free-sw.html').

   * GNUnet must minimize the amount of personally identifiable
     information exposed.

   * GNUnet must be fully distributed and resilient to external attacks
     and rogue participants.

   * GNUnet must be self-organizing and not depend on administrators or
     centralized infrastructure.

   * GNUnet must inform the user which other participants have to be
     trusted when establishing private communications.

   * GNUnet must be open and permit new peers to join.

   * GNUnet must support a diverse range of applications and devices.

   * GNUnet must use compartmentalization to protect sensitive
     information.

   * The GNUnet architecture must be resource efficient.

   * GNUnet must provide incentives for peers to contribute more
     resources than they consume.


File: gnunet.info,  Node: Privacy and Anonymity,  Next: Practicality,  Prev: Design Principles,  Up: Philosophy

2.2 Privacy and Anonymity
=========================

The GNUnet protocols minimize the leakage of personally identifiable
information of participants and do not allow adversaries to control,
track, monitor or censor users activities. The GNUnet protocols also
make it as hard as possible to disrupt operations by participating in
the network with malicious intent.

   Analyzing participant's activities becomes more difficult as the
number of peers and applications that generate traffic on the network
grows, even if the additional traffic generated is not related to
anonymous communication. This is one of the reasons why GNUnet is
developed as a peer-to-peer framework where many applications share the
lower layers of an increasingly complex protocol stack. The GNUnet
architecture encourages many different forms of peer-to-peer
applications.


File: gnunet.info,  Node: Practicality,  Prev: Privacy and Anonymity,  Up: Philosophy

2.3 Practicality
================

Whereever possible GNUnet allows the peer to adjust its operations and
functionalities to specific use cases. A GNUnet peer running on a
mobile device with limited battery for example might choose not to
relay traffic for other participants.

   For certain applications like file-sharing GNUnet allows participants
to trade degrees of anonymity in exchange for increased efficiency.
However, it is not possible for any user's efficiency requirements to
compromise the anonymity of any other user.


File: gnunet.info,  Node: Key Concepts,  Next: Installing GNUnet,  Prev: Philosophy,  Up: Top

3 Key Concepts
**************

In this section, the fundamental concepts of GNUnet are explained.
Most of them are also described in our research papers.  First, some of
the concepts used in the GNUnet framework are detailed.  The second
part describes concepts specific to anonymous file-sharing.

* Menu:

* Authentication::
* Accounting to Encourage Resource Sharing::
* Confidentiality::
* Anonymity::
* Deniability::
* Peer Identities::
* Zones in the GNU Name System (GNS Zones)::
* Egos::


File: gnunet.info,  Node: Authentication,  Next: Accounting to Encourage Resource Sharing,  Up: Key Concepts

3.1 Authentication
==================

Almost all peer-to-peer communications in GNUnet are between mutually
authenticated peers. The authentication works by using ECDHE, that is a
DH (Diffie--Hellman) key exchange using ephemeral elliptic curve
cryptography. The ephemeral ECC (Elliptic Curve Cryptography) keys are
signed using ECDSA (ECDSA (http://en.wikipedia.org/wiki/ECDSA)).  The
shared secret from ECDHE is used to create a pair of session keys
(using HKDF) which are then used to encrypt the communication between
the two peers using both 256-bit AES (Advanced Encryption Standard) and
256-bit Twofish (with independently derived secret keys).  As only the
two participating hosts know the shared secret, this authenticates each
packet without requiring signatures each time. GNUnet uses SHA-512
(Secure Hash Algorithm) hash codes to verify the integrity of messages.

   In GNUnet, the identity of a host is its public key. For that reason,
man-in-the-middle attacks will not break the authentication or
accounting goals. Essentially, for GNUnet, the IP of the host has
nothing to do with the identity of the host. As the public key is the
only thing that truly matters, faking an IP, a port or any other
property of the underlying transport protocol is irrelevant. In fact,
GNUnet peers can use multiple IPs (IPv4 and IPv6) on multiple ports --
or even not use the IP protocol at all (by running directly on layer 2).

   GNUnet uses a special type of message to communicate a binding
between public (ECC) keys to their current network address. These
messages are commonly called `HELLO's or `peer advertisements'.  They
contain the public key of the peer and its current network addresses
for various transport services.  A transport service is a special kind
of shared library that provides (possibly unreliable, out-of-order)
message delivery between peers.  For the UDP and TCP transport
services, a network address is an IP and a port.  GNUnet can also use
other transports (HTTP, HTTPS, WLAN, etc.) which use various other
forms of addresses. Note that any node can have many different active
transport services at the same time, and each of these can have a
different addresses.  Binding messages expire after at most a week (the
timeout can be shorter if the user configures the node appropriately).
This expiration ensures that the network will eventually get rid of
outdated advertisements.

   For more information, refer to the following paper:

   Ronaldo A. Ferreira, Christian Grothoff, and Paul Ruth.  A Transport
Layer Abstraction for Peer-to-Peer Networks Proceedings of the 3rd
International Symposium on Cluster Computing and the Grid (GRID 2003),
2003.
(https://git.gnunet.org/bibliography.git/plain/docs/transport.pdf
(https://git.gnunet.org/bibliography.git/plain/docs/transport.pdf))


File: gnunet.info,  Node: Accounting to Encourage Resource Sharing,  Next: Confidentiality,  Prev: Authentication,  Up: Key Concepts

3.2 Accounting to Encourage Resource Sharing
============================================

Most distributed P2P networks suffer from a lack of defenses or
precautions against attacks in the form of freeloading.  While the
intentions of an attacker and a freeloader are different, their effect
on the network is the same; they both render it useless.  Most simple
attacks on networks such as `Gnutella' involve flooding the network
with traffic, particularly with queries that are, in the worst case,
multiplied by the network.

   In order to ensure that freeloaders or attackers have a minimal
impact on the network, GNUnet's file-sharing implementation (`FS') tries
to distinguish good (contributing) nodes from malicious (freeloading)
nodes. In GNUnet, every file-sharing node keeps track of the behavior
of every other node it has been in contact with. Many requests
(depending on the application) are transmitted with a priority (or
importance) level.  That priority is used to establish how important
the sender believes this request is. If a peer responds to an important
request, the recipient will increase its trust in the responder: the
responder contributed resources.  If a peer is too busy to answer all
requests, it needs to prioritize.  For that, peers do not take the
priorities of the requests received at face value.  First, they check
how much they trust the sender, and depending on that amount of trust
they assign the request a (possibly lower) effective priority. Then,
they drop the requests with the lowest effective priority to satisfy
their resource constraints. This way, GNUnet's economic model ensures
that nodes that are not currently considered to have a surplus in
contributions will not be served if the network load is high.

   For more information, refer to the following paper: Christian
Grothoff. An Excess-Based Economic Model for Resource Allocation in
Peer-to-Peer Networks. Wirtschaftsinformatik, June 2003.
(https://git.gnunet.org/bibliography.git/plain/docs/ebe.pdf
(https://git.gnunet.org/bibliography.git/plain/docs/ebe.pdf))


File: gnunet.info,  Node: Confidentiality,  Next: Anonymity,  Prev: Accounting to Encourage Resource Sharing,  Up: Key Concepts

3.3 Confidentiality
===================

Adversaries (malicious, bad actors) outside of GNUnet are not supposed
to know what kind of actions a peer is involved in. Only the specific
neighbor of a peer that is the corresponding sender or recipient of a
message may know its contents, and even then application protocols may
place further restrictions on that knowledge.  In order to ensure
confidentiality, GNUnet uses link encryption, that is each message
exchanged between two peers is encrypted using a pair of keys only
known to these two peers.  Encrypting traffic like this makes any kind
of traffic analysis much harder. Naturally, for some applications, it
may still be desirable if even neighbors cannot determine the concrete
contents of a message.  In GNUnet, this problem is addressed by the
specific application-level protocols. See for example the following
sections *note Anonymity::, *note How file-sharing achieves Anonymity::,
and *note Deniability::.


File: gnunet.info,  Node: Anonymity,  Next: Deniability,  Prev: Confidentiality,  Up: Key Concepts

3.4 Anonymity
=============

* Menu:

* How file-sharing achieves Anonymity::

   Providing anonymity for users is the central goal for the anonymous
file-sharing application. Many other design decisions follow in the
footsteps of this requirement.  Anonymity is never absolute. While
there are various scientific metrics (Claudia Díaz, Stefaan Seys,
Joris Claessens, and Bart Preneel. Towards measuring anonymity.  2002.
(https://git.gnunet.org/bibliography.git/plain/docs/article-89.pdf
(https://git.gnunet.org/bibliography.git/plain/docs/article-89.pdf)))
that can help quantify the level of anonymity that a given mechanism
provides, there is no such thing as "complete anonymity".

   GNUnet's file-sharing implementation allows users to select for each
operation (publish, search, download) the desired level of anonymity.
The metric used is based on the amount of cover traffic needed to hide
the request.

   While there is no clear way to relate the amount of available cover
traffic to traditional scientific metrics such as the anonymity set or
information leakage, it is probably the best metric available to a peer
with a purely local view of the world, in that it does not rely on
unreliable external information or a particular adversary model.

   The default anonymity level is `1', which uses anonymous routing but
imposes no minimal requirements on cover traffic. It is possible to
forego anonymity when this is not required. The anonymity level of `0'
allows GNUnet to use more efficient, non-anonymous routing.


File: gnunet.info,  Node: How file-sharing achieves Anonymity,  Up: Anonymity

3.4.1 How file-sharing achieves Anonymity
-----------------------------------------

Contrary to other designs, we do not believe that users achieve strong
anonymity just because their requests are obfuscated by a couple of
indirections. This is not sufficient if the adversary uses traffic
analysis.  The threat model used for anonymous file sharing in GNUnet
assumes that the adversary is quite powerful.  In particular, we assume
that the adversary can see all the traffic on the Internet. And while
we assume that the adversary can not break our encryption, we assume
that the adversary has many participating nodes in the network and that
it can thus see many of the node-to-node interactions since it controls
some of the nodes.

   The system tries to achieve anonymity based on the idea that users
can be anonymous if they can hide their actions in the traffic created
by other users.  Hiding actions in the traffic of other users requires
participating in the traffic, bringing back the traditional technique
of using indirection and source rewriting. Source rewriting is required
to gain anonymity since otherwise an adversary could tell if a message
originated from a host by looking at the source address. If all packets
look like they originate from one node, the adversary can not tell
which ones originate from that node and which ones were routed.  Note
that in this mindset, any node can decide to break the source-rewriting
paradigm without violating the protocol, as this only reduces the
amount of traffic that a node can hide its own traffic in.

   If we want to hide our actions in the traffic of other nodes, we
must make our traffic indistinguishable from the traffic that we route
for others.  As our queries must have us as the receiver of the reply
(otherwise they would be useless), we must put ourselves as the receiver
of replies that actually go to other hosts; in other words, we must
indirect replies.  Unlike other systems, in anonymous file-sharing as
implemented on top of GNUnet we do not have to indirect the replies if
we don't think we need more traffic to hide our own actions.

   This increases the efficiency of the network as we can indirect less
under higher load.  Refer to the following paper for more: Krista
Bennett and Christian Grothoff.  GAP -- practical anonymous networking.
In Proceedings of Designing Privacy Enhancing Technologies, 2003.
(https://git.gnunet.org/bibliography.git/plain/docs/aff.pdf
(https://git.gnunet.org/bibliography.git/plain/docs/aff.pdf))


File: gnunet.info,  Node: Deniability,  Next: Peer Identities,  Prev: Anonymity,  Up: Key Concepts

3.5 Deniability
===============

Even if the user that downloads data and the server that provides data
are anonymous, the intermediaries may still be targets. In particular,
if the intermediaries can find out which queries or which content they
are processing, a strong adversary could try to force them to censor
certain materials.

   With the file-encoding used by GNUnet's anonymous file-sharing, this
problem does not arise.  The reason is that queries and replies are
transmitted in an encrypted format such that intermediaries cannot tell
what the query is for or what the content is about.  Mind that this is
not the same encryption as the link-encryption between the nodes.
GNUnet has encryption on the network layer (link encryption,
confidentiality, authentication) and again on the application layer
(provided by `gnunet-publish', `gnunet-download', `gnunet-search' and
`gnunet-fs-gtk').

   Refer to the following paper for more: Christian Grothoff, Krista
Grothoff, Tzvetan Horozov, and Jussi T. Lindgren.  An Encoding for
Censorship-Resistant Sharing.  2009.
(https://git.gnunet.org/bibliography.git/plain/docs/ecrs.pdf
(https://git.gnunet.org/bibliography.git/plain/docs/ecrs.pdf))


File: gnunet.info,  Node: Peer Identities,  Next: Zones in the GNU Name System (GNS Zones),  Prev: Deniability,  Up: Key Concepts

3.6 Peer Identities
===================

Peer identities are used to identify peers in the network and are unique
for each peer. The identity for a peer is simply its public key, which
is generated along with a private key the peer is started for the first
time.  While the identity is binary data, it is often expressed as
ASCII string.  For example, the following is a peer identity as you
might see it in various places:

     UAT1S6PMPITLBKSJ2DGV341JI6KF7B66AC4JVCN9811NNEGQLUN0

You can find your peer identity by running `gnunet-peerinfo -s'.


File: gnunet.info,  Node: Zones in the GNU Name System (GNS Zones),  Next: Egos,  Prev: Peer Identities,  Up: Key Concepts

3.7 Zones in the GNU Name System (GNS Zones)
============================================

GNS (Matthias Wachs, Martin Schanzenbach, and Christian Grothoff.  A
Censorship-Resistant, Privacy-Enhancing and Fully Decentralized Name
System. In proceedings of 13th International Conference on Cryptology
and Network Security (CANS 2014). 2014.
https://git.gnunet.org/bibliography.git/plain/docs/gns2014wachs.pdf
(https://git.gnunet.org/bibliography.git/plain/docs/gns2014wachs.pdf))
zones are similar to those of DNS zones, but instead of a hierarchy of
authorities to governing their use, GNS zones are controlled by a
private key.  When you create a record in a DNS zone, that information
is stored in your nameserver. Anyone trying to resolve your domain then
gets pointed (hopefully) by the centralised authority to your
nameserver.  Whereas GNS, being fully decentralized by design, stores
that information in DHT. The validity of the records is assured
cryptographically, by signing them with the private key of the
respective zone.

   Anyone trying to resolve records in a zone of your domain can then
verify the signature of the records they get from the DHT and be
assured that they are indeed from the respective zone.  To make this
work, there is a 1:1 correspondence between zones and their
public-private key pairs.  So when we talk about the owner of a GNS
zone, that's really the owner of the private key.  And a user accessing
a zone needs to somehow specify the corresponding public key first.


File: gnunet.info,  Node: Egos,  Prev: Zones in the GNU Name System (GNS Zones),  Up: Key Concepts

3.8 Egos
========

Egos are your "identities" in GNUnet. Any user can assume multiple
identities, for example to separate their activities online. Egos can
correspond to "pseudonyms" or "real-world identities". Technically an
ego is first of all a key pair of a public- and private-key.


File: gnunet.info,  Node: Installing GNUnet,  Next: Using GNUnet,  Prev: Key Concepts,  Up: Top

4 Installing GNUnet
*******************

This guide is intended for those who want to install Gnunet from
source. For instructions on how to install GNUnet as a binary package
please refer to the official documentation of your operating system or
package manager.

   For understanding this guide properly it is important to know that
there are two different ways of running GNUnet:

   * the _single-user setup_

   * the _multi-user setup_

   The latter variant has a better security model and requires extra
preparation before running `make install' and a different
configuration. Beginners who want to quickly try out GNUnet can use the
_single-user setup_.

* Menu:

* Installing dependencies::
* Getting the Source Code::
* Create user and groups for the system services::
* Preparing and Compiling the Source Code::
* Installation::
* Minimal configuration::
* Checking the Installation::
* The graphical configuration interface::
* Config Leftovers::


File: gnunet.info,  Node: Installing dependencies,  Next: Getting the Source Code,  Up: Installing GNUnet

4.1 Installing dependencies
===========================

GNUnet needs few libraries and applications for being able to run and
another few optional ones for using certain features. Preferably they
should be installed with a package manager.

   The mandatory libraries and applications are
   * autoconf 2.59 or above

   * automake 1.11.1 or above

   * gettext

   * glibc (read below, other libcs work)

   * GnuTLS 3.2.12 or above, recommended to be linked against libunbound

   * GNU make 4.0 or higher (other make implementations do work)

   * iptables (on Linux systems)

   * libtool 2.2 or above

   * libltdl (part of libtool)

   * libgcrypt 1.6 or above

   * libidn2 or libidn

   * libmicrohttpd 0.9.63 or above

   * libunistring

   * libgmp

   * libgnurl or libcurl (libcurl has to be linked to GnuTLS) 7.35.0 or
     above

   * Texinfo 5.2 or above (for building the documentation)

   * Texlive 2012 or above (for building the documentation, and for
     gnunet-bcd)

   * makeinfo 4.8 or above

   * pkgconf (or pkg-config)

   * zlib

   Glibc is required for certain NSS features:

     One mechanism of integrating GNS with legacy applications via NSS is
     not available if this is disabled. But applications that don't use the
     glibc for NS resolution won't work anyway with this, so little is lost
     on *BSD systems.
     GNS via direct use or via the HTTP or DNS proxies is unaffected.

   Other libcs should work, the resulting builds just don't include the
glibc NSS specific code. One example is the build against NetBSD's libc
as detailed in `https://bugs.gnunet.org/view.php?id=5605'.

   In addition GNUnet needs at least one of these three databases (at
the minimum sqlite3)
   * sqlite + libsqlite 3.8 or above (the default, requires no further
     configuration)

   * postgres + libpq

   * mysql + libmysqlclient

   These are the dependencies only required for certain features
   * miniupnpc (for traversing NAT boxes more reliably)

   * libnss

   * libopus (for running the GNUnet conversation telephony application)

   * libogg (for running the GNUnet conversation telephony application)

   * gstreamer OR libpulse (for running the GNUnet conversation
     telephony application)

   * bluez (for bluetooth support)

   * libextractor (optional but highly recommended, read below)

   * libpbc (for attribute-based encryption and the identity provider
     subsystem)

   * libgabe (for attribute-based encryption and the identity provider
     subsystem)

   * texi2mdoc (for automatic mdoc generation)

   * perl5 for some utilities (which are not installed)

   * libjanson

   About libextractor being optional:
     While libextractor ("LE") is optional, it is recommended to build gnunet
     against it. If you install it later, you won't benefit from libextractor.
     If you are a distributor, we recommend to split LE into basis + plugins
     rather than making LE an option as an afterthought by the user.  LE
     itself is very small, but its dependency chain on first, second, third
     etc level can be big.  There is a small effect on privacy if your LE
     build differs from one which includes all plugins (plugins are build as
     shared objects): if users publish a directory with a mixture of file
     types (for example mpeg, jpeg, png, gif) the configuration of LE could
     leak which plugins are installed for which filetypes are not providing
     more details.  However, this leak is just a minor concern.

   These are the test-suite requirements:
   * python3.6 or higher

   * gnunet (installation first)

   * some core-utils: which(1), bc(1), curl(1), sed(1), awk(1), etc.

   * a shell (very few Bash scripts, the majority are POSIX sh scripts)

   These are runtime requirements:
   * nss (the certutil binary, for gnunet-gns-proxy-setup-ca)

   * openssl (openssl binary, for gnunet-gns-proxy-setup-ca)


File: gnunet.info,  Node: Getting the Source Code,  Next: Create user and groups for the system services,  Prev: Installing dependencies,  Up: Installing GNUnet

4.2 Getting the Source Code
===========================

You can either download the source code using git (you obviously need
git installed) or as an archive.

   Using git type
     git clone https://git.gnunet.org/gnunet.git

   The archive can be found at `https://ftpmirror.gnu.org/gnu/gnunet/'.
Extract it using a graphical archive tool or `tar':
     tar xzvf gnunet-0.12.0.tar.gz

   In the next chapter we will assume that the source code is available
in the home directory at `~/gnunet'.


File: gnunet.info,  Node: Create user and groups for the system services,  Next: Preparing and Compiling the Source Code,  Prev: Getting the Source Code,  Up: Installing GNUnet

4.3 Create user and groups for the system services
==================================================

For the single-user setup this section can be skipped.

   The multi-user setup means that there are _system services_, which
are run once per machine as a dedicated system user (called `gnunet')
and _user services_ which can be started by every user who wants to use
GNUnet applications. The user services communicate with the system
services over unix domain sockets. To gain permissions to read and
write those sockets the users running GNUnet applications will need to
be in the `gnunet' group. In addition the group `gnunetdns' may be
needed (see below).

   Create user `gnunet' who is member of the group `gnunet'
(automatically created) and specify a home directory where the GNUnet
services will store persistant data such as information about peers.
     $ sudo useradd --system --home-dir /var/lib/gnunet --create-home gnunet

   Now add your own user to the `gnunet' group.

     $ sudo usermod -aG gnunet alice

   Create a group `gnunetdns'. This allows using `setgid' in a way that
only the DNS service can run the `gnunet-helper-dns' binary. This is
only needed if _system-wide DNS interception_ will be used. For more
information see *Note Configuring system-wide DNS interception::.

     $ sudo groupadd gnunetdns


File: gnunet.info,  Node: Preparing and Compiling the Source Code,  Next: Installation,  Prev: Create user and groups for the system services,  Up: Installing GNUnet

4.4 Preparing and Compiling the Source Code
===========================================

For preparing the source code for compilation a bootstrap script and
`configure' has to be run from the source code directory. When running
`configure' the following options can be specified to customize the
compilation and installation process:

   * `--disable-documentation' - don't build the documentation

   * `--enable-logging=[LOGLEVEL]' - choose a loglevel (`debug',
     `info', `warning' or `error')

   * `--prefix=[PATH]' - the directory where the GNUnet libraries and
     binaries will be installed

   * `--with-extractor=[PATH]' - the path to libextractor

   * `--with-libidn=[PATH]' - the path to libidn

   * `--with-libidn2=[PATH]' - the path to libidn2 (takes priority over
     libidn if both are found)

   * `--with-microhttpd=[PATH]' - the path to libmicrohttpd

   * `--with-sqlite=[PATH]' - the path to libsqlite

   * `--with-zlib=[PATH]' - the path to zlib

   Note that the list above is not always up to date and you should
check the output of `./configure --help', read the `configure.ac' or
send an email asking for assistance if you are in doubt of any
configure options or require fixes for your operating system.

   The following example configures the installation prefix
`/usr/local' and disables building the documentation
     $ cd ~/gnunet
     $ ./bootstrap
     $ configure --prefix=/usr/local --disable-documentation

   After running the bootstrap script and `configure' successfully the
source code can be compiled with make. Here `-j5' specifies that 5
threads should be used.
     $ make -j5


File: gnunet.info,  Node: Installation,  Next: Minimal configuration,  Prev: Preparing and Compiling the Source Code,  Up: Installing GNUnet

4.5 Installation
================

The compiled binaries can be installed using `make install'. It needs
to be run as root (or with sudo) because some binaries need the `suid'
bit set. Without that some features (e.g. the VPN service, system-wide
DNS interception, NAT traversal using ICMP) will not work.

     $ sudo make install

* Menu:

* NSS plugin (Optional)::
* Installing the GNS Certificate Authority (Optional)::


File: gnunet.info,  Node: NSS plugin (Optional),  Next: Installing the GNS Certificate Authority (Optional),  Up: Installation

4.5.1 NSS plugin (Optional)
---------------------------

The installation of the NSS plugin is only necessary if GNS resolution
shall be used with legacy applications (that only support DNS).

   One important library is the GNS plugin for NSS (the name services
switch) which allows using GNS (the GNU name system) in the normal DNS
resolution process. Unfortunately NSS expects it in a specific location
(probably `/lib') which may differ from the installation prefix (see
`--prefix' option in the previous section). This is why the plugin has
to be installed manually.

   Find the directory where nss plugins are installed on your system,
e.g.

     $ ls -l /lib/libnss_*
     /lib/libnss_mymachines.so.2
     /lib/libnss_resolve.so.2
     /lib/libnss_myhostname.so.2
     /lib/libnss_systemd.so.2

   Copy the GNS NSS plugin to that directory:

     cp ~/gnunet/src/gns/nss/.libs/libnss_gns.so.2 /lib

   Now, to activate the plugin, you need to edit your
`/etc/nsswitch.conf' where you should find a line like this:

     hosts: files mdns4_minimal [NOTFOUND=return] dns mdns4

   The exact details may differ a bit, which is fine. Add the text
`"gns [NOTFOUND=return]"' after `"files"'.

     hosts: files gns [NOTFOUND=return] mdns4_minimal [NOTFOUND=return] dns mdns4


File: gnunet.info,  Node: Installing the GNS Certificate Authority (Optional),  Prev: NSS plugin (Optional),  Up: Installation

4.5.2 Installing the GNS Certificate Authority (Optional)
---------------------------------------------------------

Installing the GNS certificate authority is only necessary if GNS shall
be used in a browser.

   The GNS Certificate authority can provide TLS certificates for GNS
names while downloading webpages from legacy webservers. This allows
browsers to use HTTPS in combinations with GNS name resolution.

   To install it execute the GNS CA-setup script. So far Firefox and
Chromium are supported.

     $ gnunet-gns-proxy-setup-ca

   A local proxy server, that takes care of the name resolution and
provides certificates on-the-fly needs to be started:

     $ /usr/lib/gnunet/libexec/gnunet-gns-proxy

   Now GNS should work in browsers that are configured to use a SOCKS
proxy on `localhost:7777'.


File: gnunet.info,  Node: Minimal configuration,  Next: Checking the Installation,  Prev: Installation,  Up: Installing GNUnet

4.6 Minimal configuration
=========================

GNUnet needs a configuration file to start. For the _single-user setup_
an empty file is sufficient:

     $ touch ~/.config/gnunet.conf

   For the _multi-user setup_ we need an extra config file for the
system services. The default location is `/etc/gnunet.conf'. The minimal
content of that file which activates the system services roll is:

     [arm]
     START_SYSTEM_SERVICES = YES
     START_USER_SERVICES = NO

   The config file for the user services (`~/.config/gnunet.conf') needs
the opposite configuration to activate the user services roll:

     [arm]
     START_SYSTEM_SERVICES = NO
     START_USER_SERVICES = YES


File: gnunet.info,  Node: Checking the Installation,  Next: The graphical configuration interface,  Prev: Minimal configuration,  Up: Installing GNUnet

4.7 Checking the Installation
=============================

This section describes a quick, casual way to check if your GNUnet
installation works. However, if it does not, we do not cover steps for
recovery -- for this, please study the instructions provided in the
developer handbook as well as the system-specific instruction in the
source code repository.  Please note that the system specific
instructions are not provided as part of this handbook!

* Menu:

* Starting GNUnet::
* gnunet-gtk::
* Statistics::
* Peer Information::


File: gnunet.info,  Node: Starting GNUnet,  Next: gnunet-gtk,  Up: Checking the Installation

4.7.1 Starting GNUnet
---------------------

The GNUnet services are started and stopped by the ARM service
(Automatic Restart Manager). For the _single-user setup_ a simple

     $ gnunet-arm -s

   starts a default set of services. Later GNUnet applications can
request more services to start without additional user interaction.
GNUnet can be stopped again using the `-e' option:

     $ gnunet-arm -e

   The list of running services can be displayed using the `-I' option.
It should look similar to this example:

     $ gnunet-arm -I
     Running services:
     topology (gnunet-daemon-topology)
     nat (gnunet-service-nat)
     vpn (gnunet-service-vpn)
     gns (gnunet-service-gns)
     cadet (gnunet-service-cadet)
     namecache (gnunet-service-namecache)
     hostlist (gnunet-daemon-hostlist)
     revocation (gnunet-service-revocation)
     ats (gnunet-service-ats)
     peerinfo (gnunet-service-peerinfo)
     zonemaster (gnunet-service-zonemaster)
     zonemaster-monitor (gnunet-service-zonemaster-monitor)
     dht (gnunet-service-dht)
     namestore (gnunet-service-namestore)
     set (gnunet-service-set)
     statistics (gnunet-service-statistics)
     nse (gnunet-service-nse)
     fs (gnunet-service-fs)
     peerstore (gnunet-service-peerstore)
     core (gnunet-service-core)
     rest (gnunet-rest-server)
     transport (gnunet-service-transport)
     datastore (gnunet-service-datastore)

   For the _multi-user setup_ first the system services need to be
started as the system user, i.e. the user `gnunet' needs to execute
`gnunet-arm -s'. This should be done by the system's init system.  Then
the user who wants to start GNUnet applications has to run `gnunet-arm
-s' too. It is recommented to automate this, e.g. using the user's
crontab.


File: gnunet.info,  Node: gnunet-gtk,  Next: Statistics,  Prev: Starting GNUnet,  Up: Checking the Installation

4.7.2 gnunet-gtk
----------------

The `gnunet-gtk' package contains several graphical user interfaces for
the respective GNUnet applications.  Currently these interfaces cover:

   * Statistics

   * Peer Information

   * GNU Name System

   * File Sharing

   * Conversation

   * Setup

   Previously, many of these interfaces were combined into one
application called `gnunet-gtk', with different tabs for each
interface. This combined application has been removed in version
0.11.0, but each of the interfaces is still available as a standalone
application (`gnunet-statistics-gtk' for statistics, `gnunet-fs-gtk'
for filesharing, etc).


File: gnunet.info,  Node: Statistics,  Next: Peer Information,  Prev: gnunet-gtk,  Up: Checking the Installation

4.7.3 Statistics
----------------

We assume that you have started gnunet via `gnunet-arm' or via your
system-provided method for starting services.  First, you should launch
GNUnet's graphical statistics interface.  You can do this from the
command-line by typing

     gnunet-statistics-gtk

   If your peer is running correctly, you should see a bunch of lines,
all of which should be "significantly" above zero (at least if your
peer has been running for more than a few seconds). The lines indicate
how many other peers your peer is connected to (via different
mechanisms) and how large the entire overlay network is currently
estimated to be. The X-axis represents time (in seconds since the start
of `gnunet-statistics-gtk').

   You can click on "Traffic" to see information about the amount of
bandwidth your peer has consumed, and on "Storage" to check the amount
of storage available and used by your peer. Note that "Traffic" is
plotted cumulatively, so you should see a strict upwards trend in the
traffic.

   The term "peer" is a common word used in federated and distributed
networks to describe a participating device which is connected to the
network. Thus, your Personal Computer or whatever it is you are looking
at the Gtk+ interface describes a "Peer" or a "Node".


File: gnunet.info,  Node: Peer Information,  Prev: Statistics,  Up: Checking the Installation

4.7.4 Peer Information
----------------------

First, you should launch the peer information graphical user interface.
You can do this from the command-line by typing

     $ gnunet-peerinfo-gtk

   Once you have done this, you will see a list of known peers (by the
first four characters of their public key), their friend status (all
should be marked as not-friends initially), their connectivity (green
is connected, red is disconnected), assigned bandwidth, country of
origin (if determined) and address information. If hardly any peers are
listed and/or if there are very few peers with a green light for
connectivity, there is likely a problem with your network configuration.


File: gnunet.info,  Node: The graphical configuration interface,  Next: Config Leftovers,  Prev: Checking the Installation,  Up: Installing GNUnet

4.8 The graphical configuration interface
=========================================

If you also would like to use `gnunet-gtk' and `gnunet-setup' (highly
recommended for beginners), do:

* Menu:

* Configuring your peer::
* Configuring the Friend-to-Friend (F2F) mode::
* Configuring the hostlist to bootstrap::
* Configuration of the HOSTLIST proxy settings::
* Configuring your peer to provide a hostlist ::
* Configuring the datastore::
* Configuring the MySQL database::
* Reasons for using MySQL::
* Reasons for not using MySQL::
* Setup Instructions::
* Testing::
* Performance Tuning::
* Setup for running Testcases::
* Configuring the Postgres database::
* Reasons to use Postgres::
* Reasons not to use Postgres::
* Manual setup instructions::
* Testing the setup manually::
* Configuring the datacache::
* Configuring the file-sharing service::
* Configuring logging::
* Configuring the transport service and plugins::
* Configuring the WLAN transport plugin::
* Configuring HTTP(S) reverse proxy functionality using Apache or nginx::
* Blacklisting peers::
* Configuration of the HTTP and HTTPS transport plugins::
* Configuring the GNU Name System::
* Configuring the GNUnet VPN::
* Bandwidth Configuration::
* Configuring NAT::
* Peer configuration for distributors (e.g. Operating Systems)::


File: gnunet.info,  Node: Configuring your peer,  Next: Configuring the Friend-to-Friend (F2F) mode,  Up: The graphical configuration interface

4.8.1 Configuring your peer
---------------------------

This chapter will describe the various configuration options in GNUnet.

   The easiest way to configure your peer is to use the `gnunet-setup'
tool.  `gnunet-setup' is part of the `gnunet-gtk' package. You might
have to install it separately.

   Many of the specific sections from this chapter actually are linked
from within `gnunet-setup' to help you while using the setup tool.

   While you can also configure your peer by editing the configuration
file by hand, this is not recommended for anyone except for developers
as it requires a more in-depth understanding of the configuration files
and internal dependencies of GNUnet.


File: gnunet.info,  Node: Configuring the Friend-to-Friend (F2F) mode,  Next: Configuring the hostlist to bootstrap,  Prev: Configuring your peer,  Up: The graphical configuration interface

4.8.2 Configuring the Friend-to-Friend (F2F) mode
-------------------------------------------------

GNUnet knows three basic modes of operation:
   * In standard "peer-to-peer" mode, your peer will connect to any
     peer.

   * In the pure "friend-to-friend" mode, your peer will ONLY connect
     to peers from a list of friends specified in the configuration.

   * Finally, in mixed mode, GNUnet will only connect to arbitrary
     peers if it has at least a specified number of connections to
     friends.

   When configuring any of the F2F ("friend-to-friend") modes, you
first need to create a file with the peer identities of your friends.
Ask your friends to run

     $ gnunet-peerinfo -sq

The resulting output of this command needs to be added to your
`friends' file, which is simply a plain text file with one line per
friend with the output from the above command.

   You then specify the location of your `friends' file in the
`FRIENDS' option of the "topology" section.

   Once you have created the `friends' file, you can tell GNUnet to only
connect to your friends by setting the `FRIENDS-ONLY' option (again in
the "topology" section) to YES.

   If you want to run in mixed-mode, set "FRIENDS-ONLY" to NO and
configure a minimum number of friends to have (before connecting to
arbitrary peers) under the "MINIMUM-FRIENDS" option.

   If you want to operate in normal P2P-only mode, simply set
`MINIMUM-FRIENDS' to zero and `FRIENDS_ONLY' to NO.  This is the
default.


File: gnunet.info,  Node: Configuring the hostlist to bootstrap,  Next: Configuration of the HOSTLIST proxy settings,  Prev: Configuring the Friend-to-Friend (F2F) mode,  Up: The graphical configuration interface

4.8.3 Configuring the hostlist to bootstrap
-------------------------------------------

After installing the software you need to get connected to the GNUnet
network. The configuration file included in your download is already
configured to connect you to the GNUnet network.  In this section the
relevant configuration settings are explained.

   To get an initial connection to the GNUnet network and to get to know
peers already connected to the network you can use the so called
"bootstrap servers".  These servers can give you a list of peers
connected to the network.  To use these bootstrap servers you have to
configure the hostlist daemon to activate bootstrapping.

   To activate bootstrapping, edit the `[hostlist]'-section in your
configuration file. You have to set the argument `-b' in the options
line:

     [hostlist]
     OPTIONS = -b

   Additionally you have to specify which server you want to use.  The
default bootstrapping server is "http://v10.gnunet.org/hostlist
(http://v10.gnunet.org/hostlist)".  [^] To set the server you have to
edit the line "SERVERS" in the hostlist section. To use the default
server you should set the lines to

     SERVERS = http://v10.gnunet.org/hostlist [^]

To use bootstrapping your configuration file should include these lines:

     [hostlist]
     OPTIONS = -b
     SERVERS = http://v10.gnunet.org/hostlist [^]

Besides using bootstrap servers you can configure your GNUnet peer to
receive hostlist advertisements.  Peers offering hostlists to other
peers can send advertisement messages to peers that connect to them. If
you configure your peer to receive these messages, your peer can
download these lists and connect to the peers included. These lists are
persistent, which means that they are saved to your hard disk regularly
and are loaded during startup.

   To activate hostlist learning you have to add the `-e' switch to the
`OPTIONS' line in the hostlist section:

     [hostlist]
     OPTIONS = -b -e

Furthermore you can specify in which file the lists are saved.  To save
the lists in the file `hostlists.file' just add the line:

     HOSTLISTFILE = hostlists.file

Best practice is to activate both bootstrapping and hostlist learning.
So your configuration file should include these lines:

     [hostlist]
     OPTIONS = -b -e
     HTTPPORT = 8080
     SERVERS = http://v10.gnunet.org/hostlist [^]
     HOSTLISTFILE = $SERVICEHOME/hostlists.file


File: gnunet.info,  Node: Configuration of the HOSTLIST proxy settings,  Next: Configuring your peer to provide a hostlist,  Prev: Configuring the hostlist to bootstrap,  Up: The graphical configuration interface

4.8.4 Configuration of the HOSTLIST proxy settings
--------------------------------------------------

The hostlist client can be configured to use a proxy to connect to the
hostlist server.  This functionality can be configured in the
configuration file directly or using the `gnunet-setup' tool.

   The hostlist client supports the following proxy types at the moment:

   * HTTP and HTTP 1.0 only proxy

   * SOCKS 4/4a/5/5 with hostname

   In addition authentication at the proxy with username and password
can be configured.

   To configure proxy support for the hostlist client in the
`gnunet-setup' tool, select the "hostlist" tab and select the
appropriate proxy type.  The hostname or IP address (including port if
required) has to be entered in the "Proxy hostname" textbox. If
required, enter username and password in the "Proxy username" and
"Proxy password" boxes.  Be aware that this information will be stored
in the configuration in plain text (TODO: Add explanation and
generalize the part in Chapter 3.6 about the encrypted home).

   To provide these options directly in the configuration, you can
enter the following settings in the `[hostlist]' section of the
configuration:

     # Type of proxy server,
     # Valid values: HTTP, HTTP_1_0, SOCKS4, SOCKS5, SOCKS4A, SOCKS5_HOSTNAME
     # Default: HTTP
     # PROXY_TYPE = HTTP

     # Hostname or IP of proxy server
     # PROXY =
     # User name for proxy server
     # PROXY_USERNAME =
     # User password for proxy server
     # PROXY_PASSWORD =


File: gnunet.info,  Node: Configuring your peer to provide a hostlist,  Next: Configuring the datastore,  Prev: Configuration of the HOSTLIST proxy settings,  Up: The graphical configuration interface

4.8.5 Configuring your peer to provide a hostlist
-------------------------------------------------

If you operate a peer permanently connected to GNUnet you can configure
your peer to act as a hostlist server, providing other peers the list of
peers known to him.

   Your server can act as a bootstrap server and peers needing to
obtain a list of peers can contact it to download this list.  To
download this hostlist the peer uses HTTP.  For this reason you have to
build your peer with libgnurl (or libcurl) and microhttpd support.

   To configure your peer to act as a bootstrap server you have to add
the `-p' option to `OPTIONS' in the `[hostlist]' section of your
configuration file.  Besides that you have to specify a port number for
the http server.  In conclusion you have to add the following lines:

     [hostlist]
     HTTPPORT = 12980
     OPTIONS = -p

If your peer acts as a bootstrap server other peers should know about
that. You can advertise the hostlist your are providing to other peers.
Peers connecting to your peer will get a message containing an
advertisement for your hostlist and the URL where it can be downloaded.
If this peer is in learning mode, it will test the hostlist and, in the
case it can obtain the list successfully, it will save it for
bootstrapping.

   To activate hostlist advertisement on your peer, you have to set the
following lines in your configuration file:

     [hostlist]
     EXTERNAL_DNS_NAME = example.org
     HTTPPORT = 12981
     OPTIONS = -p -a

With this configuration your peer will a act as a bootstrap server and
advertise this hostlist to other peers connecting to it.  The URL used
to download the list will be `http://example.org:12981/
(http://example.org:12981/)'.

   Please notice:

   * The hostlist is not human readable, so you should not try to
     download it using your webbrowser. Just point your GNUnet peer to
     the address!

   * Advertising without providing a hostlist does not make sense and
     will not work.


File: gnunet.info,  Node: Configuring the datastore,  Next: Configuring the MySQL database,  Prev: Configuring your peer to provide a hostlist,  Up: The graphical configuration interface

4.8.6 Configuring the datastore
-------------------------------

The datastore is what GNUnet uses for long-term storage of file-sharing
data. Note that long-term does not mean 'forever' since content does
have an expiration date, and of course storage space is finite (and
hence sometimes content may have to be discarded).

   Use the `QUOTA' option to specify how many bytes of storage space
you are willing to dedicate to GNUnet.

   In addition to specifying the maximum space GNUnet is allowed to use
for the datastore, you need to specify which database GNUnet should use
to do so. Currently, you have the choice between sqLite, MySQL and
Postgres.


File: gnunet.info,  Node: Configuring the MySQL database,  Next: Reasons for using MySQL,  Prev: Configuring the datastore,  Up: The graphical configuration interface

4.8.7 Configuring the MySQL database
------------------------------------

This section describes how to setup the MySQL database for GNUnet.

   Note that the mysql plugin does NOT work with mysql before 4.1 since
we need prepared statements.  We are generally testing the code against
MySQL 5.1 at this point.


File: gnunet.info,  Node: Reasons for using MySQL,  Next: Reasons for not using MySQL,  Prev: Configuring the MySQL database,  Up: The graphical configuration interface

4.8.8 Reasons for using MySQL
-----------------------------

   * On up-to-date hardware where mysql can be used comfortably, this
     module will have better performance than the other database
     choices (according to our tests).

   * Its often possible to recover the mysql database from internal
     inconsistencies. Some of the other databases do not support repair.


File: gnunet.info,  Node: Reasons for not using MySQL,  Next: Setup Instructions,  Prev: Reasons for using MySQL,  Up: The graphical configuration interface

4.8.9 Reasons for not using MySQL
---------------------------------

   * Memory usage (likely not an issue if you have more than 1 GB)

   * Complex manual setup


File: gnunet.info,  Node: Setup Instructions,  Next: Testing,  Prev: Reasons for not using MySQL,  Up: The graphical configuration interface

4.8.10 Setup Instructions
-------------------------

   * In `gnunet.conf' set in section `DATASTORE' the value for
     `DATABASE' to `mysql'.

   * Access mysql as root:

          $ mysql -u root -p

     and issue the following commands, replacing $USER with the username
     that will be running `gnunet-arm' (so typically "gnunet"):

          CREATE DATABASE gnunet;
          GRANT select,insert,update,delete,create,alter,drop,create \
          temporary tables ON gnunet.* TO $USER@localhost;
          SET PASSWORD FOR $USER@localhost=PASSWORD('$the_password_you_like');
          FLUSH PRIVILEGES;

   * In the $HOME directory of $USER, create a `.my.cnf' file with the
     following lines

          [client]
          user=$USER
          password=$the_password_you_like


   That's it. Note that `.my.cnf' file is a slight security risk unless
its on a safe partition. The `$HOME/.my.cnf' can of course be a
symbolic link.  Luckily $USER has only privileges to mess up GNUnet's
tables, which should be pretty harmless.


File: gnunet.info,  Node: Testing,  Next: Performance Tuning,  Prev: Setup Instructions,  Up: The graphical configuration interface

4.8.11 Testing
--------------

You should briefly try if the database connection works. First, login
as $USER. Then use:

     $ mysql -u $USER
     mysql> use gnunet;

If you get the message

     Database changed

it probably works.

   If you get

     ERROR 2002: Can't connect to local MySQL server
     through socket '/tmp/mysql.sock' (2)

it may be resolvable by

     ln -s /var/run/mysqld/mysqld.sock /tmp/mysql.sock

so there may be some additional trouble depending on your mysql setup.


File: gnunet.info,  Node: Performance Tuning,  Next: Setup for running Testcases,  Prev: Testing,  Up: The graphical configuration interface

4.8.12 Performance Tuning
-------------------------

For GNUnet, you probably want to set the option

     innodb_flush_log_at_trx_commit = 0

for a rather dramatic boost in MySQL performance. However, this reduces
the "safety" of your database as with this options you may loose
transactions during a power outage.  While this is totally harmless for
GNUnet, the option applies to all applications using MySQL. So you
should set it if (and only if) GNUnet is the only application on your
system using MySQL.


File: gnunet.info,  Node: Setup for running Testcases,  Next: Configuring the Postgres database,  Prev: Performance Tuning,  Up: The graphical configuration interface

4.8.13 Setup for running Testcases
----------------------------------

If you want to run the testcases, you must create a second database
"gnunetcheck" with the same username and password. This database will
then be used for testing (`make check').


File: gnunet.info,  Node: Configuring the Postgres database,  Next: Reasons to use Postgres,  Prev: Setup for running Testcases,  Up: The graphical configuration interface

4.8.14 Configuring the Postgres database
----------------------------------------

This text describes how to setup the Postgres database for GNUnet.

   This Postgres plugin was developed for Postgres 8.3 but might work
for earlier versions as well.


File: gnunet.info,  Node: Reasons to use Postgres,  Next: Reasons not to use Postgres,  Prev: Configuring the Postgres database,  Up: The graphical configuration interface

4.8.15 Reasons to use Postgres
------------------------------

   * Easier to setup than MySQL

   * Real database


File: gnunet.info,  Node: Reasons not to use Postgres,  Next: Manual setup instructions,  Prev: Reasons to use Postgres,  Up: The graphical configuration interface

4.8.16 Reasons not to use Postgres
----------------------------------

   * Quite slow

   * Still some manual setup required


File: gnunet.info,  Node: Manual setup instructions,  Next: Testing the setup manually,  Prev: Reasons not to use Postgres,  Up: The graphical configuration interface

4.8.17 Manual setup instructions
--------------------------------

   * In `gnunet.conf' set in section `DATASTORE' the value for
     `DATABASE' to `postgres'.

   * Access Postgres to create a user:

    with Postgres 8.x, use:
               # su - postgres
               $ createuser

          and enter the name of the user running GNUnet for the role
          interactively.  Then, when prompted, do not set it to
          superuser, allow the creation of databases, and do not allow
          the creation of new roles.

    with Postgres 9.x, use:
               # su - postgres
               $ createuser -d $GNUNET_USER

          where $GNUNET_USER is the name of the user running GNUnet.


   * As that user (so typically as user "gnunet"), create a database
     (or two):

          $ createdb gnunet
          # this way you can run "make check"
          $ createdb gnunetcheck


   Now you should be able to start `gnunet-arm'.


File: gnunet.info,  Node: Testing the setup manually,  Next: Configuring the datacache,  Prev: Manual setup instructions,  Up: The graphical configuration interface

4.8.18 Testing the setup manually
---------------------------------

You may want to try if the database connection works. First, again login
as the user who will run `gnunet-arm'. Then use:

     $ psql gnunet # or gnunetcheck
     gnunet=> \dt

If, after you have started `gnunet-arm' at least once, you get a
`gn090' table here, it probably works.


File: gnunet.info,  Node: Configuring the datacache,  Next: Configuring the file-sharing service,  Prev: Testing the setup manually,  Up: The graphical configuration interface

4.8.19 Configuring the datacache
--------------------------------

The datacache is what GNUnet uses for storing temporary data. This data
is expected to be wiped completely each time GNUnet is restarted (or the
system is rebooted).

   You need to specify how many bytes GNUnet is allowed to use for the
datacache using the `QUOTA' option in the section `[dhtcache]'.
Furthermore, you need to specify which database backend should be used
to store the data. Currently, you have the choice between sqLite, MySQL
and Postgres.


File: gnunet.info,  Node: Configuring the file-sharing service,  Next: Configuring logging,  Prev: Configuring the datacache,  Up: The graphical configuration interface

4.8.20 Configuring the file-sharing service
-------------------------------------------

In order to use GNUnet for file-sharing, you first need to make sure
that the file-sharing service is loaded.  This is done by setting the
`START_ON_DEMAND' option in section `[fs]' to "YES". Alternatively, you
can run

     $ gnunet-arm -i fs

to start the file-sharing service by hand.

   Except for configuring the database and the datacache the only
important option for file-sharing is content migration.

   Content migration allows your peer to cache content from other peers
as well as send out content stored on your system without explicit
requests.  This content replication has positive and negative impacts
on both system performance and privacy.

   FIXME: discuss the trade-offs. Here is some older text about it...

   Setting this option to YES allows gnunetd to migrate data to the
local machine. Setting this option to YES is highly recommended for
efficiency.  Its also the default. If you set this value to YES, GNUnet
will store content on your machine that you cannot decrypt.  While this
may protect you from liability if the judge is sane, it may not
(IANAL). If you put illegal content on your machine yourself, setting
this option to YES will probably increase your chances to get away with
it since you can plausibly deny that you inserted the content.  Note
that in either case, your anonymity would have to be broken first
(which may be possible depending on the size of the GNUnet network and
the strength of the adversary).


File: gnunet.info,  Node: Configuring logging,  Next: Configuring the transport service and plugins,  Prev: Configuring the file-sharing service,  Up: The graphical configuration interface

4.8.21 Configuring logging
--------------------------

Since version 0.9.0, logging in GNUnet is controlled via the `-L' and
`-l' options.  Using `-L', a log level can be specified. With log level
`ERROR' only serious errors are logged.  The default log level is
`WARNING' which causes anything of concern to be logged.  Log level
`INFO' can be used to log anything that might be interesting
information whereas `DEBUG' can be used by developers to log debugging
messages (but you need to run `./configure' with
`--enable-logging=verbose' to get them compiled).  The `-l' option is
used to specify the log file.

   Since most GNUnet services are managed by `gnunet-arm', using the
`-l' or `-L' options directly is not possible.  Instead, they can be
specified using the `OPTIONS' configuration value in the respective
section for the respective service.  In order to enable logging
globally without editing the `OPTIONS' values for each service,
`gnunet-arm' supports a `GLOBAL_POSTFIX' option.  The value specified
here is given as an extra option to all services for which the
configuration does contain a service-specific `OPTIONS' field.

   `GLOBAL_POSTFIX' can contain the special sequence "{}" which is
replaced by the name of the service that is being started.
Furthermore, `GLOBAL_POSTFIX' is special in that sequences starting
with "$" anywhere in the string are expanded (according to options in
`PATHS'); this expansion otherwise is only happening for filenames and
then the "$" must be the first character in the option. Both of these
restrictions do not apply to `GLOBAL_POSTFIX'.  Note that specifying
`%' anywhere in the `GLOBAL_POSTFIX' disables both of these features.

   In summary, in order to get all services to log at level `INFO' to
log-files called `SERVICENAME-logs', the following global prefix should
be used:

     GLOBAL_POSTFIX = -l $SERVICEHOME/{}-logs -L INFO


File: gnunet.info,  Node: Configuring the transport service and plugins,  Next: Configuring the WLAN transport plugin,  Prev: Configuring logging,  Up: The graphical configuration interface

4.8.22 Configuring the transport service and plugins
----------------------------------------------------

The transport service in GNUnet is responsible to maintain basic
connectivity to other peers.  Besides initiating and keeping
connections alive it is also responsible for address validation.

   The GNUnet transport supports more than one transport protocol.
These protocols are configured together with the transport service.

   The configuration section for the transport service itself is quite
similar to all the other services

     START_ON_DEMAND = YES
     @UNIXONLY@ PORT = 2091
     HOSTNAME = localhost
     HOME = $SERVICEHOME
     CONFIG = $DEFAULTCONFIG
     BINARY = gnunet-service-transport
     #PREFIX = valgrind
     NEIGHBOUR_LIMIT = 50
     ACCEPT_FROM = 127.0.0.1;
     ACCEPT_FROM6 = ::1;
     PLUGINS = tcp udp
     UNIXPATH = /tmp/gnunet-service-transport.sock

   Different are the settings for the plugins to load `PLUGINS'.  The
first setting specifies which transport plugins to load.

   * transport-unix A plugin for local only communication with UNIX
     domain sockets. Used for testing and available on unix systems
     only. Just set the port

          [transport-unix]
          PORT = 22086
          TESTING_IGNORE_KEYS = ACCEPT_FROM;

   * transport-tcp A plugin for communication with TCP. Set port to 0
     for client mode with outbound only connections

          [transport-tcp]
          # Use 0 to ONLY advertise as a peer behind NAT (no port binding)
          PORT = 2086
          ADVERTISED_PORT = 2086
          TESTING_IGNORE_KEYS = ACCEPT_FROM;
          # Maximum number of open TCP connections allowed
          MAX_CONNECTIONS = 128

   * transport-udp A plugin for communication with UDP. Supports peer
     discovery using broadcasts.

          [transport-udp]
          PORT = 2086
          BROADCAST = YES
          BROADCAST_INTERVAL = 30 s
          MAX_BPS = 1000000
          TESTING_IGNORE_KEYS = ACCEPT_FROM;

   * transport-http HTTP and HTTPS support is split in two part: a
     client plugin initiating outbound connections and a server part
     accepting connections from the client. The client plugin just
     takes the maximum number of connections as an argument.

          [transport-http_client]
          MAX_CONNECTIONS = 128
          TESTING_IGNORE_KEYS = ACCEPT_FROM;

          [transport-https_client]
          MAX_CONNECTIONS = 128
          TESTING_IGNORE_KEYS = ACCEPT_FROM;

     The server has a port configured and the maximum number of
     connections.  The HTTPS part has two files with the certificate
     key and the certificate file.

     The server plugin supports reverse proxies, so a external hostname
     can be set using the `EXTERNAL_HOSTNAME' setting.  The webserver
     under this address should forward the request to the peer and the
     configure port.

          [transport-http_server]
          EXTERNAL_HOSTNAME = fulcrum.net.in.tum.de/gnunet
          PORT = 1080
          MAX_CONNECTIONS = 128
          TESTING_IGNORE_KEYS = ACCEPT_FROM;

          [transport-https_server]
          PORT = 4433
          CRYPTO_INIT = NORMAL
          KEY_FILE = https.key
          CERT_FILE = https.cert
          MAX_CONNECTIONS = 128
          TESTING_IGNORE_KEYS = ACCEPT_FROM;

   * transport-wlan

     The next section describes how to setup the WLAN plugin, so here
     only the settings. Just specify the interface to use:

          [transport-wlan]
          # Name of the interface in monitor mode (typically monX)
          INTERFACE = mon0
          # Real hardware, no testing
          TESTMODE = 0
          TESTING_IGNORE_KEYS = ACCEPT_FROM;


File: gnunet.info,  Node: Configuring the WLAN transport plugin,  Next: Configuring HTTP(S) reverse proxy functionality using Apache or nginx,  Prev: Configuring the transport service and plugins,  Up: The graphical configuration interface

4.8.23 Configuring the WLAN transport plugin
--------------------------------------------

The wlan transport plugin enables GNUnet to send and to receive data on
a wlan interface.  It has not to be connected to a wlan network as long
as sender and receiver are on the same channel. This enables you to get
connection to GNUnet where no internet access is possible, for example
during catastrophes or when censorship cuts you off from the internet.

* Menu:

* Requirements for the WLAN plugin::
* Configuration::
* Before starting GNUnet::
* Limitations and known bugs::


File: gnunet.info,  Node: Requirements for the WLAN plugin,  Next: Configuration,  Up: Configuring the WLAN transport plugin

4.8.23.1 Requirements for the WLAN plugin
.........................................

   * wlan network card with monitor support and packet injection (see
     aircrack-ng.org (http://www.aircrack-ng.org/))

   * Linux kernel with mac80211 stack, introduced in 2.6.22, tested with
     2.6.35 and 2.6.38

   * Wlantools to create the a monitor interface, tested with airmon-ng
     of the aircrack-ng package


File: gnunet.info,  Node: Configuration,  Next: Before starting GNUnet,  Prev: Requirements for the WLAN plugin,  Up: Configuring the WLAN transport plugin

4.8.23.2 Configuration
......................

There are the following options for the wlan plugin (they should be like
this in your default config file, you only need to adjust them if the
values are incorrect for your system)

     # section for the wlan transport plugin
     [transport-wlan]
     # interface to use, more information in the
     # "Before starting GNUnet" section of the handbook.
     INTERFACE = mon0
     # testmode for developers:
     # 0 use wlan interface,
     #1 or 2 use loopback driver for tests 1 = server, 2 = client
     TESTMODE = 0


File: gnunet.info,  Node: Before starting GNUnet,  Next: Limitations and known bugs,  Prev: Configuration,  Up: Configuring the WLAN transport plugin

4.8.23.3 Before starting GNUnet
...............................

Before starting GNUnet, you have to make sure that your wlan interface
is in monitor mode.  One way to put the wlan interface into monitor
mode (if your interface name is wlan0) is by executing:

     sudo airmon-ng start wlan0

Here is an example what the result should look like:

     Interface Chipset Driver
     wlan0 Intel 4965 a/b/g/n iwl4965 - [phy0]
     (monitor mode enabled on mon0)

The monitor interface is mon0 is the one that you have to put into the
configuration file.


File: gnunet.info,  Node: Limitations and known bugs,  Prev: Before starting GNUnet,  Up: Configuring the WLAN transport plugin

4.8.23.4 Limitations and known bugs
...................................

Wlan speed is at the maximum of 1 Mbit/s because support for choosing
the wlan speed with packet injection was removed in newer kernels.
Please pester the kernel developers about fixing this.

   The interface channel depends on the wlan network that the card is
connected to. If no connection has been made since the start of the
computer, it is usually the first channel of the card.  Peers will only
find each other and communicate if they are on the same channel.
Channels must be set manually, i.e. using:

     iwconfig wlan0 channel 1


File: gnunet.info,  Node: Configuring HTTP(S) reverse proxy functionality using Apache or nginx,  Next: Blacklisting peers,  Prev: Configuring the WLAN transport plugin,  Up: The graphical configuration interface

4.8.24 Configuring HTTP(S) reverse proxy functionality using Apache or nginx
----------------------------------------------------------------------------

The HTTP plugin supports data transfer using reverse proxies. A reverse
proxy forwards the HTTP request he receives with a certain URL to
another webserver, here a GNUnet peer.

   So if you have a running Apache or nginx webserver you can configure
it to be a GNUnet reverse proxy. Especially if you have a well-known
webiste this improves censorship resistance since it looks as normal
surfing behaviour.

   To do so, you have to do two things:

   * Configure your webserver to forward the GNUnet HTTP traffic

   * Configure your GNUnet peer to announce the respective address

   As an example we want to use GNUnet peer running:

   * HTTP server plugin on `gnunet.foo.org:1080'

   * HTTPS server plugin on `gnunet.foo.org:4433'

   * A apache or nginx webserver on http://www.foo.org:80/
     (http://www.foo.org/)

   * A apache or nginx webserver on https://www.foo.org:443/

   And we want the webserver to accept GNUnet traffic under
`http://www.foo.org/bar/'. The required steps are described here:

* Menu:

* Reverse Proxy - Configure your Apache2 HTTP webserver::
* Reverse Proxy - Configure your Apache2 HTTPS webserver::
* Reverse Proxy - Configure your nginx HTTPS webserver::
* Reverse Proxy - Configure your nginx HTTP webserver::
* Reverse Proxy - Configure your GNUnet peer::


File: gnunet.info,  Node: Reverse Proxy - Configure your Apache2 HTTP webserver,  Next: Reverse Proxy - Configure your Apache2 HTTPS webserver,  Up: Configuring HTTP(S) reverse proxy functionality using Apache or nginx

4.8.24.1 Reverse Proxy - Configure your Apache2 HTTP webserver
..............................................................

First of all you need mod_proxy installed.

   Edit your webserver configuration. Edit `/etc/apache2/apache2.conf'
or the site-specific configuration file.

   In the respective `server config',`virtual host' or `directory'
section add the following lines:

     ProxyTimeout 300
     ProxyRequests Off
     <Location /bar/ >
     ProxyPass http://gnunet.foo.org:1080/
     ProxyPassReverse http://gnunet.foo.org:1080/
     </Location>


File: gnunet.info,  Node: Reverse Proxy - Configure your Apache2 HTTPS webserver,  Next: Reverse Proxy - Configure your nginx HTTPS webserver,  Prev: Reverse Proxy - Configure your Apache2 HTTP webserver,  Up: Configuring HTTP(S) reverse proxy functionality using Apache or nginx

4.8.24.2 Reverse Proxy - Configure your Apache2 HTTPS webserver
...............................................................

We assume that you already have an HTTPS server running, if not please
check how to configure a HTTPS host. An uncomplicated to use example is
the example configuration file for Apache2/HTTPD provided in
`apache2/sites-available/default-ssl'.

   In the respective HTTPS `server config',`virtual host' or
`directory' section add the following lines:

     SSLProxyEngine On
     ProxyTimeout 300
     ProxyRequests Off
     <Location /bar/ >
     ProxyPass https://gnunet.foo.org:4433/
     ProxyPassReverse https://gnunet.foo.org:4433/
     </Location>

More information about the apache mod_proxy configuration can be found
in the Apache documentation
(http://httpd.apache.org/docs/2.2/mod/mod_proxy.html#proxypass).


File: gnunet.info,  Node: Reverse Proxy - Configure your nginx HTTPS webserver,  Next: Reverse Proxy - Configure your nginx HTTP webserver,  Prev: Reverse Proxy - Configure your Apache2 HTTPS webserver,  Up: Configuring HTTP(S) reverse proxy functionality using Apache or nginx

4.8.24.3 Reverse Proxy - Configure your nginx HTTPS webserver
.............................................................

Since nginx does not support chunked encoding, you first of all have to
install the `chunkin' module (http://wiki.nginx.org/HttpChunkinModule).

   To enable chunkin add:

     chunkin on;
     error_page 411 = @my_411_error;
     location @my_411_error {
     chunkin_resume;
     }

Edit your webserver configuration. Edit `/etc/nginx/nginx.conf' or the
site-specific configuration file.

   In the `server' section add:

     location /bar/ {
     proxy_pass http://gnunet.foo.org:1080/;
     proxy_buffering off;
     proxy_connect_timeout 5; # more than http_server
     proxy_read_timeout 350; # 60 default, 300s is GNUnet's idle timeout
     proxy_http_version 1.1; # 1.0 default
     proxy_next_upstream error timeout invalid_header http_500 http_503 http_502 http_504;
     }


File: gnunet.info,  Node: Reverse Proxy - Configure your nginx HTTP webserver,  Next: Reverse Proxy - Configure your GNUnet peer,  Prev: Reverse Proxy - Configure your nginx HTTPS webserver,  Up: Configuring HTTP(S) reverse proxy functionality using Apache or nginx

4.8.24.4 Reverse Proxy - Configure your nginx HTTP webserver
............................................................

Edit your webserver configuration. Edit `/etc/nginx/nginx.conf' or the
site-specific configuration file.

   In the `server' section add:

     ssl_session_timeout 6m;
     location /bar/
     {
     proxy_pass https://gnunet.foo.org:4433/;
     proxy_buffering off;
     proxy_connect_timeout 5; # more than http_server
     proxy_read_timeout 350; # 60 default, 300s is GNUnet's idle timeout
     proxy_http_version 1.1; # 1.0 default
     proxy_next_upstream error timeout invalid_header http_500 http_503 http_502 http_504;
     }


File: gnunet.info,  Node: Reverse Proxy - Configure your GNUnet peer,  Prev: Reverse Proxy - Configure your nginx HTTP webserver,  Up: Configuring HTTP(S) reverse proxy functionality using Apache or nginx

4.8.24.5 Reverse Proxy - Configure your GNUnet peer
...................................................

To have your GNUnet peer announce the address, you have to specify the
`EXTERNAL_HOSTNAME' option in the `[transport-http_server]' section:

     [transport-http_server]
     EXTERNAL_HOSTNAME = http://www.foo.org/bar/

and/or `[transport-https_server]' section:

     [transport-https_server]
     EXTERNAL_HOSTNAME = https://www.foo.org/bar/

Now restart your webserver and your peer...


File: gnunet.info,  Node: Blacklisting peers,  Next: Configuration of the HTTP and HTTPS transport plugins,  Prev: Configuring HTTP(S) reverse proxy functionality using Apache or nginx,  Up: The graphical configuration interface

4.8.25 Blacklisting peers
-------------------------

Transport service supports to deny connecting to a specific peer of to a
specific peer with a specific transport plugin using te blacklisting
component of transport service. With blacklisting it is possible to deny
connections to specific peers of to use a specific plugin to a specific
peer. Peers can be blacklisted using the configuration or a blacklist
client can be asked.

   To blacklist peers using the configuration you have to add a section
to your configuration containing the peer id of the peer to blacklist
and the plugin if required.

   Examples:

   To blacklist connections to P565... on peer AG2P... using tcp add:

     [transport-blacklist AG2PHES1BARB9IJCPAMJTFPVJ5V3A72S3F2A8SBUB8DAQ2V0O3V8G6G2JU56FHGFOHMQVKBSQFV98TCGTC3RJ1NINP82G0RC00N1520]
     P565723JO1C2HSN6J29TAQ22MN6CI8HTMUU55T0FUQG4CMDGGEQ8UCNBKUMB94GC8R9G4FB2SF9LDOBAJ6AMINBP4JHHDD6L7VD801G = tcp

   To blacklist connections to P565... on peer AG2P... using all
plugins add:

     [transport-blacklist-AG2PHES1BARB9IJCPAMJTFPVJ5V3A72S3F2A8SBUB8DAQ2V0O3V8G6G2JU56FHGFOHMQVKBSQFV98TCGTC3RJ1NINP82G0RC00N1520]
     P565723JO1C2HSN6J29TAQ22MN6CI8HTMUU55T0FUQG4CMDGGEQ8UCNBKUMB94GC8R9G4FB2SF9LDOBAJ6AMINBP4JHHDD6L7VD801G =

   You can also add a blacklist client usign the blacklist API. On a
blacklist check, blacklisting first checks internally if the peer is
blacklisted and if not, it asks the blacklisting clients. Clients are
asked if it is OK to connect to a peer ID, the plugin is omitted.

   On blacklist check for (peer, plugin)

   * Do we have a local blacklist entry for this peer and this plugin?

   * YES: disallow connection

   * Do we have a local blacklist entry for this peer and all plugins?

   * YES: disallow connection

   * Does one of the clients disallow?

   * YES: disallow connection


File: gnunet.info,  Node: Configuration of the HTTP and HTTPS transport plugins,  Next: Configuring the GNU Name System,  Prev: Blacklisting peers,  Up: The graphical configuration interface

4.8.26 Configuration of the HTTP and HTTPS transport plugins
------------------------------------------------------------

The client parts of the http and https transport plugins can be
configured to use a proxy to connect to the hostlist server. This
functionality can be configured in the configuration file directly or
using the gnunet-setup tool.

   Both the HTTP and HTTPS clients support the following proxy types at
the moment:

   * HTTP 1.1 proxy

   * SOCKS 4/4a/5/5 with hostname

   In addition authentication at the proxy with username and password
can be configured.

   To configure proxy support for the clients in the gnunet-setup tool,
select the "transport" tab and activate the respective plugin. Now you
can select the appropriate proxy type. The hostname or IP address
(including port if required) has to be entered in the "Proxy hostname"
textbox. If required, enter username and password in the "Proxy
username" and "Proxy password" boxes. Be aware that these information
will be stored in the configuration in plain text.

   To configure these options directly in the configuration, you can
configure the following settings in the `[transport-http_client]' and
`[transport-https_client]' section of the configuration:

     # Type of proxy server,
     # Valid values: HTTP, SOCKS4, SOCKS5, SOCKS4A, SOCKS5_HOSTNAME
     # Default: HTTP
     # PROXY_TYPE = HTTP

     # Hostname or IP of proxy server
     # PROXY =
     # User name for proxy server
     # PROXY_USERNAME =
     # User password for proxy server
     # PROXY_PASSWORD =


File: gnunet.info,  Node: Configuring the GNU Name System,  Next: Configuring the GNUnet VPN,  Prev: Configuration of the HTTP and HTTPS transport plugins,  Up: The graphical configuration interface

4.8.27 Configuring the GNU Name System
--------------------------------------

* Menu:

* Configuring system-wide DNS interception::
* Configuring the GNS nsswitch plugin::
* GNS Proxy Setup::
* Setup of the GNS CA::
* Testing the GNS setup::
* Migrating existing DNS zones into GNS::


File: gnunet.info,  Node: Configuring system-wide DNS interception,  Next: Configuring the GNS nsswitch plugin,  Up: Configuring the GNU Name System

4.8.27.1 Configuring system-wide DNS interception
.................................................

Before you install GNUnet, make sure you have a user and group 'gnunet'
as well as an empty group 'gnunetdns'.

   When using GNUnet with system-wide DNS interception, it is absolutely
necessary for all GNUnet service processes to be started by
`gnunet-service-arm' as user and group 'gnunet'. You also need to be
sure to run `make install' as root (or use the `sudo' option to
configure) to grant GNUnet sufficient privileges.

   With this setup, all that is required for enabling system-wide DNS
interception is for some GNUnet component (VPN or GNS) to request it.
The `gnunet-service-dns' will then start helper programs that will make
the necessary changes to your firewall (`iptables') rules.

   Note that this will NOT work if your system sends out DNS traffic to
a link-local IPv6 address, as in this case GNUnet can intercept the
traffic, but not inject the responses from the link-local IPv6 address.
Hence you cannot use system-wide DNS interception in conjunction with
link-local IPv6-based DNS servers. If such a DNS server is used, it
will bypass GNUnet's DNS traffic interception.

   Using the GNU Name System (GNS) requires two different configuration
steps.  First of all, GNS needs to be integrated with the operating
system. Most of this section is about the operating system level
integration.

   The remainder of this chapter will detail the various methods for
configuring the use of GNS with your operating system.

   At this point in time you have different options depending on your
OS:

   * Use the gnunet-gns-proxy
     This approach works for all operating systems and is likely the
     easiest. However, it enables GNS only for browsers, not for other
     applications that might be using DNS, such as SSH.  Still, using
     the proxy is required for using HTTP with GNS and is thus
     recommended for all users. To do this, you simply have to run the
     `gnunet-gns-proxy-setup-ca' script as the user who will run the
     browser (this will create a GNS certificate authority (CA) on your
     system and import its key into your browser), then start
     `gnunet-gns-proxy' and inform your browser to use the Socks5 proxy
     which `gnunet-gns-proxy' makes available by default on port 7777.

   * Use a nsswitch plugin (recommended on GNU systems)
     This approach has the advantage of offering fully personalized
     resolution even on multi-user systems. A potential disadvantage is
     that some applications might be able to bypass GNS.

   * Use a W32 resolver plugin (recommended on W32)
     This is currently the only option on W32 systems.

   * Use system-wide DNS packet interception
     This approach is recommended for the GNUnet VPN. It can be used to
     handle GNS at the same time; however, if you only use this method,
     you will only get one root zone per machine (not so great for
     multi-user systems).

   You can combine system-wide DNS packet interception with the nsswitch
plugin.  The setup of the system-wide DNS interception is described
here. All of the other GNS-specific configuration steps are described
in the following sections.


File: gnunet.info,  Node: Configuring the GNS nsswitch plugin,  Next: GNS Proxy Setup,  Prev: Configuring system-wide DNS interception,  Up: Configuring the GNU Name System

4.8.27.2 Configuring the GNS nsswitch plugin
............................................

The Name Service Switch (NSS) is a facility in Unix-like operating
systems (in most cases provided by the GNU C Library) that provides a
variety of sources for common configuration databases and name
resolution mechanisms.  A superuser (system administrator) usually
configures the operating system's name services using the file
`/etc/nsswitch.conf'.

   GNS provides a NSS plugin to integrate GNS name resolution with the
operating system's name resolution process.  To use the GNS NSS plugin
you have to either

   * install GNUnet as root or

   * compile GNUnet with the `--with-sudo=yes' switch.

   Name resolution is controlled by the _hosts_ section in the NSS
configuration. By default this section first performs a lookup in the
`/etc/hosts' file and then in DNS.  The nsswitch file should contain a
line similar to:

     hosts: files dns [NOTFOUND=return] mdns4_minimal mdns4

Here the GNS NSS plugin can be added to perform a GNS lookup before
performing a DNS lookup.  The GNS NSS plugin has to be added to the
"hosts" section in `/etc/nsswitch.conf' file before DNS related plugins:

     ...
     hosts: files gns [NOTFOUND=return] dns mdns4_minimal mdns4
     ...

The `NOTFOUND=return' will ensure that if a `.gnu' name is not found in
GNS it will not be queried in DNS.


File: gnunet.info,  Node: GNS Proxy Setup,  Next: Setup of the GNS CA,  Prev: Configuring the GNS nsswitch plugin,  Up: Configuring the GNU Name System

4.8.27.3 GNS Proxy Setup
........................

When using the GNU Name System (GNS) to browse the WWW, there are
several issues that can be solved by adding the GNS Proxy to your setup:

   * If the target website does not support GNS, it might assume that it
     is operating under some name in the legacy DNS system (such as
     example.com). It may then attempt to set cookies for that domain,
     and the web server might expect a `Host: example.com' header in
     the request from your browser.  However, your browser might be
     using `example.gnu' for the `Host' header and might only accept
     (and send) cookies for `example.gnu'. The GNS Proxy will perform
     the necessary translations of the hostnames for cookies and HTTP
     headers (using the LEHO record for the target domain as the
     desired substitute).

   * If using HTTPS, the target site might include an SSL certificate
     which is either only valid for the LEHO domain or might match a
     TLSA record in GNS. However, your browser would expect a valid
     certificate for `example.gnu', not for some legacy domain name.
     The proxy will validate the certificate (either against LEHO or
     TLSA) and then on-the-fly produce a valid certificate for the
     exchange, signed by your own CA. Assuming you installed the CA of
     your proxy in your browser's certificate authority list, your
     browser will then trust the HTTPS/SSL/TLS connection, as the
     hostname mismatch is hidden by the proxy.

   * Finally, the proxy will in the future indicate to the server that
     it speaks GNS, which will enable server operators to deliver
     GNS-enabled web sites to your browser (and continue to deliver
     legacy links to legacy browsers)


File: gnunet.info,  Node: Setup of the GNS CA,  Next: Testing the GNS setup,  Prev: GNS Proxy Setup,  Up: Configuring the GNU Name System

4.8.27.4 Setup of the GNS CA
............................

First you need to create a CA certificate that the proxy can use.  To
do so use the provided script gnunet-gns-proxy-ca:

     $ gnunet-gns-proxy-setup-ca

This will create a personal certification authority for you and add this
authority to the firefox and chrome database. The proxy will use the
this CA certificate to generate `*.gnu' client certificates on the fly.

   Note that the proxy uses libcurl. Make sure your version of libcurl
uses GnuTLS and NOT OpenSSL. The proxy will not work with libcurl
compiled against OpenSSL.

   You can check the configuration your libcurl was build with by
running:

     curl --version

   the output will look like this (without the linebreaks):

     gnurl --version
     curl 7.56.0 (x86_64-unknown-linux-gnu) libcurl/7.56.0 \
     GnuTLS/3.5.13 zlib/1.2.11 libidn2/2.0.4
     Release-Date: 2017-10-08
     Protocols: http https
     Features: AsynchDNS IDN IPv6 Largefile NTLM SSL libz \
     TLS-SRP UnixSockets HTTPS-proxy


File: gnunet.info,  Node: Testing the GNS setup,  Next: Migrating existing DNS zones into GNS,  Prev: Setup of the GNS CA,  Up: Configuring the GNU Name System

4.8.27.5 Testing the GNS setup
..............................

Now for testing purposes we can create some records in our zone to test
the SSL functionality of the proxy:

     $ gnunet-identity -C test
     $ gnunet-namestore -a -e "1 d" -n "homepage" \
       -t A -V 131.159.74.67 -z test
     $ gnunet-namestore -a -e "1 d" -n "homepage" \
       -t LEHO -V "gnunet.org" -z test

At this point we can start the proxy. Simply execute

     $ gnunet-arm -i gns-proxy

   To run the proxy at all times in the future, you should change your
configuration as follows:

     $ gnunet-config -s gns-proxy -o AUTOSTART -V YES

Configure your browser to use this SOCKSv5 proxy using `localhost' on
port 7777.  If you use `Firefox' (or one of its derivatives/forks such
as Icecat) you also have to go to `about:config' and set the key
`network.proxy.socks_remote_dns' to `true'.

   When you visit `https://homepage.test/', you should get to the
`https://gnunet.org/' frontpage and the browser (with the correctly
configured proxy) should give you a valid SSL certificate for
`homepage.gnu' and no warnings. It should look like this:


File: gnunet.info,  Node: Migrating existing DNS zones into GNS,  Prev: Testing the GNS setup,  Up: Configuring the GNU Name System

4.8.27.6 Migrating existing DNS zones into GNS
..............................................

To migrate an existing zone into GNS use the Ascension tool.

   Ascension transfers entire zones into GNS by doing incremental zone
transfers and then adding the records to GNS.

   Compared to the gnunet-zoneimport tool it strictly uses AXFR or IXFR
depending on whether or not there exists a SOA record for the zone. If
that is the case it will take the serial as a reference point and
request the zone. The server will either answer the IXFR request with a
correct incremental zone or with the entire zone, which depends on the
server configuration.

   You can find the source code here:
`https://git.gnunet.org/ascension.git/'

   The software can be installed into a Python virtual environment like
this:
     $ python3 -m venv .venv
     $ source .venv/bin/activate
     $ python3 setup.py install

   Or installed globally like this:
     $ sudo python3 setup.py install

   Pip will then install all the necessary requirements that are needed
to run Ascension. For development purposes a virtual environment should
suffice.  Keeping a virtual environment helps with keeping things tidy
and prevents breaking of Ascension through a future Python update.

   The advantage of using a virtual environment is, that all the
dependencies can be installed separately in different versions without
touching your systems Python installation and its dependencies.

   Another way to install Ascension on Debian is to install the
python3-ascension package. It can be found within the above mentioned
Ascension git repository.  This also adds a system user ascension and
runs a GNUnet peer in the background. Attention: This only works if a
recent version of GNUnet is installed on your system. The version
number of Ascension is chosen according to the required feature level
of GNUnet. I.e. Ascension 0.11.5 is only compatible with GNUnet 0.11.5
and upwards. As Debian's packages for GNUnet are outdated even in
experimental, you will need to install GNUnet manually *Note Installing
GNUnet::.

   Please check *Note Migrating an existing DNS zone into GNS::, for
usage manual of the tool.


File: gnunet.info,  Node: Configuring the GNUnet VPN,  Next: Bandwidth Configuration,  Prev: Configuring the GNU Name System,  Up: The graphical configuration interface

4.8.28 Configuring the GNUnet VPN
---------------------------------

* Menu:

* IPv4 address for interface::
* IPv6 address for interface::
* Configuring the GNUnet VPN DNS::
* Configuring the GNUnet VPN Exit Service::
* IP Address of external DNS resolver::
* IPv4 address for Exit interface::
* IPv6 address for Exit interface::

   Before configuring the GNUnet VPN, please make sure that system-wide
DNS interception is configured properly as described in the section on
the GNUnet DNS setup. *note Configuring the GNU Name System::, if you
haven't done so already.

   The default options for the GNUnet VPN are usually sufficient to use
GNUnet as a Layer 2 for your Internet connection.  However, what you
always have to specify is which IP protocol you want to tunnel: IPv4,
IPv6 or both.  Furthermore, if you tunnel both, you most likely should
also tunnel all of your DNS requests.  You theoretically can tunnel
"only" your DNS traffic, but that usually makes little sense.

   The other options as shown on the gnunet-setup tool are:


File: gnunet.info,  Node: IPv4 address for interface,  Next: IPv6 address for interface,  Up: Configuring the GNUnet VPN

4.8.28.1 IPv4 address for interface
...................................

This is the IPv4 address the VPN interface will get. You should pick a
'private' IPv4 network that is not yet in use for you system. For
example, if you use `10.0.0.1/255.255.0.0' already, you might use
`10.1.0.1/255.255.0.0'.  If you use `10.0.0.1/255.0.0.0' already, then
you might use `192.168.0.1/255.255.0.0'.  If your system is not in a
private IP-network, using any of the above will work fine.  You should
try to make the mask of the address big enough (`255.255.0.0' or, even
better, `255.0.0.0') to allow more mappings of remote IP Addresses into
this range.  However, even a `255.255.255.0' mask will suffice for most
users.


File: gnunet.info,  Node: IPv6 address for interface,  Next: Configuring the GNUnet VPN DNS,  Prev: IPv4 address for interface,  Up: Configuring the GNUnet VPN

4.8.28.2 IPv6 address for interface
...................................

The IPv6 address the VPN interface will get. Here you can specify any
non-link-local address (the address should not begin with `fe80:').  A
subnet Unique Local Unicast (`fd00::/8' prefix) that you are currently
not using would be a good choice.


File: gnunet.info,  Node: Configuring the GNUnet VPN DNS,  Next: Configuring the GNUnet VPN Exit Service,  Prev: IPv6 address for interface,  Up: Configuring the GNUnet VPN

4.8.28.3 Configuring the GNUnet VPN DNS
.......................................

To resolve names for remote nodes, activate the DNS exit option.


File: gnunet.info,  Node: Configuring the GNUnet VPN Exit Service,  Next: IP Address of external DNS resolver,  Prev: Configuring the GNUnet VPN DNS,  Up: Configuring the GNUnet VPN

4.8.28.4 Configuring the GNUnet VPN Exit Service
................................................

If you want to allow other users to share your Internet connection (yes,
this may be dangerous, just as running a Tor exit node) or want to
provide access to services on your host (this should be less dangerous,
as long as those services are secure), you have to enable the GNUnet
exit daemon.

   You then get to specify which exit functions you want to provide. By
enabling the exit daemon, you will always automatically provide exit
functions for manually configured local services (this component of the
system is under development and not documented further at this time).
As for those services you explicitly specify the target IP address and
port, there is no significant security risk in doing so.

   Furthermore, you can serve as a DNS, IPv4 or IPv6 exit to the
Internet.  Being a DNS exit is usually pretty harmless. However,
enabling IPv4 or IPv6-exit without further precautions may enable
adversaries to access your local network, send spam, attack other
systems from your Internet connection and to other mischief that will
appear to come from your machine. This may or may not get you into
legal trouble.  If you want to allow IPv4 or IPv6-exit functionality,
you should strongly consider adding additional firewall rules manually
to protect your local network and to restrict outgoing TCP traffic
(i.e. by not allowing access to port 25). While we plan to improve
exit-filtering in the future, you're currently on your own here.
Essentially, be prepared for any kind of IP-traffic to exit the
respective TUN interface (and GNUnet will enable IP-forwarding and NAT
for the interface automatically).

   Additional configuration options of the exit as shown by the
gnunet-setup tool are:


File: gnunet.info,  Node: IP Address of external DNS resolver,  Next: IPv4 address for Exit interface,  Prev: Configuring the GNUnet VPN Exit Service,  Up: Configuring the GNUnet VPN

4.8.28.5 IP Address of external DNS resolver
............................................

If DNS traffic is to exit your machine, it will be send to this DNS
resolver. You can specify an IPv4 or IPv6 address.


File: gnunet.info,  Node: IPv4 address for Exit interface,  Next: IPv6 address for Exit interface,  Prev: IP Address of external DNS resolver,  Up: Configuring the GNUnet VPN

4.8.28.6 IPv4 address for Exit interface
........................................

This is the IPv4 address the Interface will get. Make the mask of the
address big enough (255.255.0.0 or, even better, 255.0.0.0) to allow
more mappings of IP addresses into this range. As for the VPN
interface, any unused, private IPv4 address range will do.


File: gnunet.info,  Node: IPv6 address for Exit interface,  Prev: IPv4 address for Exit interface,  Up: Configuring the GNUnet VPN

4.8.28.7 IPv6 address for Exit interface
........................................

The public IPv6 address the interface will get. If your kernel is not a
very recent kernel and you are willing to manually enable IPv6-NAT, the
IPv6 address you specify here must be a globally routed IPv6 address of
your host.

   Suppose your host has the address `2001:4ca0::1234/64', then using
`2001:4ca0::1:0/112' would be fine (keep the first 64 bits, then change
at least one bit in the range before the bitmask, in the example above
we changed bit 111 from 0 to 1).

   You may also have to configure your router to route traffic for the
entire subnet (`2001:4ca0::1:0/112' for example) through your computer
(this should be automatic with IPv6, but obviously anything can be
disabled).


File: gnunet.info,  Node: Bandwidth Configuration,  Next: Configuring NAT,  Prev: Configuring the GNUnet VPN,  Up: The graphical configuration interface

4.8.29 Bandwidth Configuration
------------------------------

You can specify how many bandwidth GNUnet is allowed to use to receive
and send data. This is important for users with limited bandwidth or
traffic volume.


File: gnunet.info,  Node: Configuring NAT,  Next: Peer configuration for distributors (e.g. Operating Systems),  Prev: Bandwidth Configuration,  Up: The graphical configuration interface

4.8.30 Configuring NAT
----------------------

Most hosts today do not have a normal global IP address but instead are
behind a router performing Network Address Translation (NAT) which
assigns each host in the local network a private IP address.  As a
result, these machines cannot trivially receive inbound connections
from the Internet. GNUnet supports NAT traversal to enable these
machines to receive incoming connections from other peers despite their
limitations.

   In an ideal world, you can press the "Attempt automatic
configuration" button in gnunet-setup to automatically configure your
peer correctly.  Alternatively, your distribution might have already
triggered this automatic configuration during the installation process.
However, automatic configuration can fail to determine the optimal
settings, resulting in your peer either not receiving as many
connections as possible, or in the worst case it not connecting to the
network at all.

   To manually configure the peer, you need to know a few things about
your network setup. First, determine if you are behind a NAT in the
first place.  This is always the case if your IP address starts with
"10.*" or "192.168.*". Next, if you have control over your NAT router,
you may choose to manually configure it to allow GNUnet traffic to your
host.  If you have configured your NAT to forward traffic on ports 2086
(and possibly 1080) to your host, you can check the "NAT ports have
been opened manually" option, which corresponds to the "PUNCHED_NAT"
option in the configuration file. If you did not punch your NAT box, it
may still be configured to support UPnP, which allows GNUnet to
automatically configure it. In that case, you need to install the
"upnpc" command, enable UPnP (or PMP) on your NAT box and set the
"Enable NAT traversal via UPnP or PMP" option (corresponding to
"ENABLE_UPNP" in the configuration file).

   Some NAT boxes can be traversed using the autonomous NAT traversal
method.  This requires certain GNUnet components to be installed with
"SUID" privileges on your system (so if you're installing on a system
you do not have administrative rights to, this will not work).  If you
installed as 'root', you can enable autonomous NAT traversal by
checking the "Enable NAT traversal using ICMP method".  The ICMP method
requires a way to determine your NAT's external (global) IP address.
This can be done using either UPnP, DynDNS, or by manual configuration.
If you have a DynDNS name or know your external IP address, you should
enter that name under "External (public) IPv4 address" (which
corresponds to the "EXTERNAL_ADDRESS" option in the configuration file).
If you leave the option empty, GNUnet will try to determine your
external IP address automatically (which may fail, in which case
autonomous NAT traversal will then not work).

   Finally, if you yourself are not behind NAT but want to be able to
connect to NATed peers using autonomous NAT traversal, you need to check
the "Enable connecting to NATed peers using ICMP method" box.


File: gnunet.info,  Node: Peer configuration for distributors (e.g. Operating Systems),  Prev: Configuring NAT,  Up: The graphical configuration interface

4.8.31 Peer configuration for distributors (e.g. Operating Systems)
-------------------------------------------------------------------

The "GNUNET_DATA_HOME" in "[PATHS]" in `/etc/gnunet.conf' should be
manually set to "/var/lib/gnunet/data/" as the default
"~/.local/share/gnunet/" is probably not that appropriate in this case.
Similarly, distributors may consider pointing "GNUNET_RUNTIME_DIR" to
"/var/run/gnunet/" and "GNUNET_HOME" to "/var/lib/gnunet/". Also,
should a distributor decide to override system defaults, all of these
changes should be done in a custom `/etc/gnunet.conf' and not in the
files in the `config.d/' directory.

   Given the proposed access permissions, the "gnunet-setup" tool must
be run as use "gnunet" (and with option "-c /etc/gnunet.conf" so that it
modifies the system configuration). As always, gnunet-setup should be
run after the GNUnet peer was stopped using "gnunet-arm -e".
Distributors might want to include a wrapper for gnunet-setup that
allows the desktop-user to "sudo" (i.e. using gtksudo) to the "gnunet"
user account and then runs "gnunet-arm -e", "gnunet-setup" and
"gnunet-arm -s" in sequence.


File: gnunet.info,  Node: Config Leftovers,  Prev: The graphical configuration interface,  Up: Installing GNUnet

4.9 Config Leftovers
====================

This section describes how to start a GNUnet peer. It assumes that you
have already compiled and installed GNUnet and its' dependencies.
Before you start a GNUnet peer, you may want to create a configuration
file using gnunet-setup (but you do not have to).  Sane defaults should
exist in your `$GNUNET_PREFIX/share/gnunet/config.d/' directory, so in
practice you could simply start without any configuration. If you want
to configure your peer later, you need to stop it before invoking the
`gnunet-setup' tool to customize further and to test your configuration
(`gnunet-setup' has build-in test functions).

   The most important option you might have to still set by hand is in
[PATHS]. Here, you use the option "GNUNET_HOME" to specify the path
where GNUnet should store its data.  It defaults to `$HOME/', which
again should work for most users.  Make sure that the directory
specified as GNUNET_HOME is writable to the user that you will use to
run GNUnet (note that you can run frontends using other users,
GNUNET_HOME must only be accessible to the user used to run the
background processes).

   You will also need to make one central decision: should all of
GNUnet be run under your normal UID, or do you want distinguish between
system-wide (user-independent) GNUnet services and personal GNUnet
services. The multi-user setup is slightly more complicated, but also
more secure and generally recommended.

* Menu:

* The Single-User Setup::
* The Multi-User Setup::
* Killing GNUnet services::
* Access Control for GNUnet::


File: gnunet.info,  Node: The Single-User Setup,  Next: The Multi-User Setup,  Up: Config Leftovers

4.9.1 The Single-User Setup
---------------------------

For the single-user setup, you do not need to do anything special and
can just start the GNUnet background processes using `gnunet-arm'.  By
default, GNUnet looks in `~/.config/gnunet.conf' for a configuration
(or `$XDG_CONFIG_HOME/gnunet.conf' if `$XDG_CONFIG_HOME' is defined).
If your configuration lives elsewhere, you need to pass the `-c
FILENAME' option to all GNUnet commands.

   Assuming the configuration file is called `~/.config/gnunet.conf',
you start your peer using the `gnunet-arm' command (say as user
`gnunet') using:

     gnunet-arm -c ~/.config/gnunet.conf -s

The "-s" option here is for "start". The command should return almost
instantly. If you want to stop GNUnet, you can use:

     gnunet-arm -c ~/.config/gnunet.conf -e

The "-e" option here is for "end".

   Note that this will only start the basic peer, no actual applications
will be available.  If you want to start the file-sharing service, use
(after starting GNUnet):

     gnunet-arm -c ~/.config/gnunet.conf -i fs

The "-i fs" option here is for "initialize" the "fs" (file-sharing)
application. You can also selectively kill only file-sharing support
using

     gnunet-arm -c ~/.config/gnunet.conf -k fs

Assuming that you want certain services (like file-sharing) to be always
automatically started whenever you start GNUnet, you can activate them
by setting "IMMEDIATE_START=YES" in the respective section of the
configuration file (for example, "[fs]"). Then GNUnet with file-sharing
support would be started whenever you enter:

     gnunet-arm -c ~/.config/gnunet.conf -s

Alternatively, you can combine the two options:

     gnunet-arm -c ~/.config/gnunet.conf -s -i fs

Using `gnunet-arm' is also the preferred method for initializing GNUnet
from `init'.

   Finally, you should edit your `crontab' (using the `crontab'
command) and insert a line
     @reboot gnunet-arm -c ~/.config/gnunet.conf -s

   to automatically start your peer whenever your system boots.


File: gnunet.info,  Node: The Multi-User Setup,  Next: Killing GNUnet services,  Prev: The Single-User Setup,  Up: Config Leftovers

4.9.2 The Multi-User Setup
--------------------------

This requires you to create a user `gnunet' and an additional group
`gnunetdns', prior to running `make install' during installation.
Then, you create a configuration file `/etc/gnunet.conf' which should
contain the lines:
     [arm]
     START_SYSTEM_SERVICES = YES
     START_USER_SERVICES = NO

Then, perform the same steps to run GNUnet as in the per-user
configuration, except as user `gnunet' (including the `crontab'
installation).  You may also want to run `gnunet-setup' to configure
your peer (databases, etc.).  Make sure to pass `-c /etc/gnunet.conf'
to all commands. If you run `gnunet-setup' as user `gnunet', you might
need to change permissions on `/etc/gnunet.conf' so that the `gnunet'
user can write to the file (during setup).

   Afterwards, you need to perform another setup step for each normal
user account from which you want to access GNUnet. First, grant the
normal user (`$USER') permission to the group gnunet:

     # adduser $USER gnunet

Then, create a configuration file in `~/.config/gnunet.conf' for the
$USER with the lines:

     [arm]
     START_SYSTEM_SERVICES = NO
     START_USER_SERVICES = YES

This will ensure that `gnunet-arm' when started by the normal user will
only run services that are per-user, and otherwise rely on the
system-wide services.  Note that the normal user may run gnunet-setup,
but the configuration would be ineffective as the system-wide services
will use `/etc/gnunet.conf' and ignore options set by individual users.

   Again, each user should then start the peer using `gnunet-arm -s' --
and strongly consider adding logic to start the peer automatically to
their crontab.

   Afterwards, you should see two (or more, if you have more than one
USER) `gnunet-service-arm' processes running in your system.


File: gnunet.info,  Node: Killing GNUnet services,  Next: Access Control for GNUnet,  Prev: The Multi-User Setup,  Up: Config Leftovers

4.9.3 Killing GNUnet services
-----------------------------

It is not necessary to stop GNUnet services explicitly when shutting
down your computer.

   It should be noted that manually killing "most" of the
`gnunet-service' processes is generally not a successful method for
stopping a peer (since `gnunet-service-arm' will instantly restart
them). The best way to explicitly stop a peer is using `gnunet-arm -e';
note that the per-user services may need to be terminated before the
system-wide services will terminate normally.


File: gnunet.info,  Node: Access Control for GNUnet,  Prev: Killing GNUnet services,  Up: Config Leftovers

4.9.4 Access Control for GNUnet
-------------------------------

This chapter documents how we plan to make access control work within
the GNUnet system for a typical peer. It should be read as a
best-practice installation guide for advanced users and builders of
binary distributions. The recommendations in this guide apply to
POSIX-systems with full support for UNIX domain sockets only.

   Note that this is an advanced topic. The discussion presumes a very
good understanding of users, groups and file permissions. Normal users
on hosts with just a single user can just install GNUnet under their own
account (and possibly allow the installer to use SUDO to grant
additional permissions for special GNUnet tools that need additional
rights).  The discussion below largely applies to installations where
multiple users share a system and to installations where the best
possible security is paramount.

   A typical GNUnet system consists of components that fall into four
categories:

User interfaces
     User interfaces are not security sensitive and are supposed to be
     run and used by normal system users.  The GTK GUIs and most
     command-line programs fall into this category.  Some command-line
     tools (like gnunet-transport) should be excluded as they offer
     low-level access that normal users should not need.

System services and support tools
     System services should always run and offer services that can then
     be accessed by the normal users.  System services do not require
     special permissions, but as they are not specific to a particular
     user, they probably should not run as a particular user. Also,
     there should typically only be one GNUnet peer per host. System
     services include the gnunet-service and gnunet-daemon programs;
     support tools include command-line programs such as gnunet-arm.

Privileged helpers
     Some GNUnet components require root rights to open raw sockets or
     perform other special operations. These gnunet-helper binaries are
     typically installed SUID and run from services or daemons.

Critical services
     Some GNUnet services (such as the DNS service) can manipulate the
     service in deep and possibly highly security sensitive ways. For
     example, the DNS service can be used to intercept and alter any
     DNS query originating from the local machine. Access to the APIs
     of these critical services and their privileged helpers must be
     tightly controlled.

* Menu:

* Recommendation - Disable access to services via TCP::
* Recommendation - Run most services as system user "gnunet"::
* Recommendation - Control access to services using group "gnunet"::
* Recommendation - Limit access to certain SUID binaries by group "gnunet"::
* Recommendation - Limit access to critical gnunet-helper-dns to group "gnunetdns"::
* Differences between "make install" and these recommendations::


File: gnunet.info,  Node: Recommendation - Disable access to services via TCP,  Next: Recommendation - Run most services as system user "gnunet",  Up: Access Control for GNUnet

4.9.4.1 Recommendation - Disable access to services via TCP
...........................................................

GNUnet services allow two types of access: via TCP socket or via UNIX
domain socket.  If the service is available via TCP, access control can
only be implemented by restricting connections to a particular range of
IP addresses.  This is acceptable for non-critical services that are
supposed to be available to all users on the local system or local
network.  However, as TCP is generally less efficient and it is rarely
the case that a single GNUnet peer is supposed to serve an entire local
network, the default configuration should disable TCP access to all
GNUnet services on systems with support for UNIX domain sockets.  Since
GNUnet 0.9.2, configuration files with TCP access disabled should be
generated by default. Users can re-enable TCP access to particular
services simply by specifying a non-zero port number in the section of
the respective service.


File: gnunet.info,  Node: Recommendation - Run most services as system user "gnunet",  Next: Recommendation - Control access to services using group "gnunet",  Prev: Recommendation - Disable access to services via TCP,  Up: Access Control for GNUnet

4.9.4.2 Recommendation - Run most services as system user "gnunet"
..................................................................

GNUnet's main services should be run as a separate user "gnunet" in a
special group "gnunet".  The user "gnunet" should start the peer using
"gnunet-arm -s" during system startup. The home directory for this user
should be `/var/lib/gnunet' and the configuration file should be
`/etc/gnunet.conf'.  Only the `gnunet' user should have the right to
access `/var/lib/gnunet' (_mode: 700_).


File: gnunet.info,  Node: Recommendation - Control access to services using group "gnunet",  Next: Recommendation - Limit access to certain SUID binaries by group "gnunet",  Prev: Recommendation - Run most services as system user "gnunet",  Up: Access Control for GNUnet

4.9.4.3 Recommendation - Control access to services using group "gnunet"
........................................................................

Users that should be allowed to use the GNUnet peer should be added to
the group "gnunet". Using GNUnet's access control mechanism for UNIX
domain sockets, those services that are considered useful to ordinary
users should be made available by setting "UNIX_MATCH_GID=YES" for those
services.  Again, as shipped, GNUnet provides reasonable defaults.
Permissions to access the transport and core subsystems might
additionally be granted without necessarily causing security concerns.
Some services, such as DNS, must NOT be made accessible to the "gnunet"
group (and should thus only be accessible to the "gnunet" user and
services running with this UID).


File: gnunet.info,  Node: Recommendation - Limit access to certain SUID binaries by group "gnunet",  Next: Recommendation - Limit access to critical gnunet-helper-dns to group "gnunetdns",  Prev: Recommendation - Control access to services using group "gnunet",  Up: Access Control for GNUnet

4.9.4.4 Recommendation - Limit access to certain SUID binaries by group "gnunet"
................................................................................

Most of GNUnet's SUID binaries should be safe even if executed by normal
users. However, it is possible to reduce the risk a little bit more by
making these binaries owned by the group "gnunet" and restricting their
execution to user of the group "gnunet" as well (4750).


File: gnunet.info,  Node: Recommendation - Limit access to critical gnunet-helper-dns to group "gnunetdns",  Next: Differences between "make install" and these recommendations,  Prev: Recommendation - Limit access to certain SUID binaries by group "gnunet",  Up: Access Control for GNUnet

4.9.4.5 Recommendation - Limit access to critical gnunet-helper-dns to group "gnunetdns"
........................................................................................

A special group "gnunetdns" should be created for controlling access to
the "gnunet-helper-dns".  The binary should then be owned by root and
be in group "gnunetdns" and be installed SUID and only be
group-executable (2750).  Note that the group "gnunetdns" should have
no users in it at all, ever.  The "gnunet-service-dns" program should
be executed by user "gnunet" (via gnunet-service-arm) with the binary
owned by the user "root" and the group "gnunetdns" and be SGID (2700).
This way, *only* "gnunet-service-dns" can change its group to
"gnunetdns" and execute the helper, and the helper can then run as root
(as per SUID).  Access to the API offered by "gnunet-service-dns" is in
turn restricted to the user "gnunet" (not the group!), which means that
only "benign" services can manipulate DNS queries using
"gnunet-service-dns".


File: gnunet.info,  Node: Differences between "make install" and these recommendations,  Prev: Recommendation - Limit access to critical gnunet-helper-dns to group "gnunetdns",  Up: Access Control for GNUnet

4.9.4.6 Differences between "make install" and these recommendations
....................................................................

The current build system does not set all permissions automatically
based on the recommendations above. In particular, it does not use the
group "gnunet" at all (so setting gnunet-helpers other than the
gnunet-helper-dns to be owned by group "gnunet" must be done manually).
Furthermore, 'make install' will silently fail to set the DNS binaries
to be owned by group "gnunetdns" unless that group already exists (!).
An alternative name for the "gnunetdns" group can be specified using the
`--with-gnunetdns=GRPNAME' configure option.


File: gnunet.info,  Node: Using GNUnet,  Next: GNUnet Contributors Handbook,  Prev: Installing GNUnet,  Up: Top

5 Using GNUnet
**************

This tutorial is supposed to give a first introduction for users trying
to do something real with GNUnet. Installation and configuration are
specifically outside of the scope of this tutorial.  Instead, we start
by briefly checking that the installation works, and then dive into
uncomplicated, concrete practical things that can be done with the
framework provided by GNUnet.

   In short, this chapter of the "GNUnet Reference Documentation" will
show you how to use the various peer-to-peer applications of the GNUnet
system.  As GNUnet evolves, we will add new sections for the various
applications that are being created.

   Comments on the content of this chapter, and extensions of it are
always welcome.

* Menu:

* Start and stop GNUnet::
* First steps - Using the GNU Name System::
* First steps - Using GNUnet Conversation::
* First steps - Using the GNUnet VPN::
* File-sharing::
* The GNU Name System::
* reclaimID Identity Provider::
* Using the Virtual Public Network::


File: gnunet.info,  Node: Start and stop GNUnet,  Next: First steps - Using the GNU Name System,  Up: Using GNUnet

5.1 Start and stop GNUnet
=========================

Prior to using any GNUnet-based application, one has to start a node:

     $ gnunet-arm -s -l gnunet.log

   To stop GNUnet:

     $ gnunet-arm -e


File: gnunet.info,  Node: First steps - Using the GNU Name System,  Next: First steps - Using GNUnet Conversation,  Prev: Start and stop GNUnet,  Up: Using GNUnet

5.2 First steps - Using the GNU Name System
===========================================

* Menu:

* Preliminaries::
* Managing Egos::
* The GNS Tab::
* Creating a Record::
* Resolving GNS records::
* Integration with Browsers::
* Creating a Business Card::
* Be Social::
* Backup of Identities and Egos::
* Revocation::
* What's Next?::


File: gnunet.info,  Node: Preliminaries,  Next: Managing Egos,  Up: First steps - Using the GNU Name System

5.2.1 Preliminaries
-------------------

".pin" is a default zone which points to a zone managed by gnunet.org.
Use `gnunet-config -s gns' to view the GNS configuration, including all
configured zones that are operated by other users.  The respective
configuration entry names start with a ".", i.e. ".pin".

   You can configure any number of top-level domains, and point them to
the respective zones of your friends!  For this, simply obtain the
respective public key (you will learn how below) and extend the
configuration:

     $ gnunet-config -s gns -n .myfriend -V PUBLIC_KEY


File: gnunet.info,  Node: Managing Egos,  Next: The GNS Tab,  Prev: Preliminaries,  Up: First steps - Using the GNU Name System

5.2.2 Managing Egos
-------------------

In GNUnet, identity management is about managing egos.  Egos can
correspond to pseudonyms or real-world identities.  If you value your
privacy, you are encouraged to use separate egos for separate
activities.

   Technically, an ego is first of all a public-private key pair, and
thus egos also always correspond to a GNS zone.  Egos are managed by
the IDENTITY service.  Note that this service has nothing to do with
the peer identity.  The IDENTITY service essentially stores the private
keys under human-readable names, and keeps a mapping of which private
key should be used for particular important system functions.  The
existing identities can be listed using the command `gnunet-identity -d'

     gnu - JTDVJC69NHU6GQS4B5721MV8VM7J6G2DVRGJV0ONIT6QH7OI6D50
     rules - GO0T87F9BPMF8NKD5A54L2AH1T0GRML539TPFSRMCEA98182QD30


File: gnunet.info,  Node: The GNS Tab,  Next: Creating a Record,  Prev: Managing Egos,  Up: First steps - Using the GNU Name System

5.2.3 The GNS Tab
-----------------

Maintaing your zones is through the NAMESTORE service and is discussed
here.  You can manage your zone using `gnunet-identity' and
`gnunet-namestore', or most conveniently using `gnunet-namestore-gtk'.

   We will use the GTK+ interface in this introduction.  Please start
`gnunet-gkt' and switch to the GNS tab, which is the tab in the middle
with the letters "GNS" connected by a graph.

   Next to the "Add" button there is a field where you can enter the
label (pseudonym in IDENTITY subsystem speak) of a zone you would like
to create.  Pushing the "Add" button will create the zone.  Afterwards,
you can change the label in the combo box below at any time.  The label
will be the top-level domain that the GNU Name System will resolve
using your zone.  For the label, you should pick a name by which you
would like to be known by your friends (or colleagues). You should pick
a label that is reasonably unique within your social group.  Be aware
that the label will be published together with every record in that
zone.

   Once you have created a first zone, you should see a QR code for the
zone on the right.  Next to it is a "Copy" button to copy the public
key string to the clipboard. You can also save the QR code image to
disk.

   Furthermore, you now can see the bottom part of the dialog.  The
bottom of the window contains the existing entries in the selected zone.


File: gnunet.info,  Node: Creating a Record,  Next: Resolving GNS records,  Prev: The GNS Tab,  Up: First steps - Using the GNU Name System

5.2.4 Creating a Record
-----------------------

We will begin by creating a simple record in your master zone.  To do
this, click on the text "<new name>" in the table. The field is
editable, allowing you to enter a fresh label. Labels are restricted to
63 characters and must not contain dots. For now, simply enter "test",
then press ENTER to confirm. This will create a new (empty) record
group under the label "test". Now click on "<new record>" next to the
new label "test". In the drop-down menu, select "A" and push ENTER to
confirm. Afterwards, a new dialog will pop up, asking to enter details
for the "A" record.

   "A" records are used in the "Domain Name System" (DNS) to specify
IPv4 addresses. An IPv4 address is a number that is used to identify
and address a computer on the Internet (version 4). Please enter
"217.92.15.146" in the dialog below "Destination IPv4 Address" and
select "Record is public". Do not change any of the other options.
Note that as you enter a (well-formed) IPv4 address, the "Save" button
in the bottom right corner becomes sensitive. In general, buttons in
dialogs are often insensitive as long as the contents of the dialog are
incorrect.

   Once finished, press the "Save" button. Back in the main dialog,
select the tiny triangle left of the "test" label. By doing so, you get
to see all of the records under "test". Note that you can right-click a
record to edit it later.


File: gnunet.info,  Node: Resolving GNS records,  Next: Integration with Browsers,  Prev: Creating a Record,  Up: First steps - Using the GNU Name System

5.2.5 Resolving GNS records
---------------------------

Next, you should try resolving your own GNS records.  The method we
found to be the most uncomplicated is to do this by explicitly
resolving using `gnunet-gns'.  For this exercise, we will assume that
you used the string "gnu" for the pseudonym (or label) of your GNS
zone.  If you used something else, replace ".gnu" with your real
pseudonym in the examples below.

   In the shell, type:

     $ gnunet-gns -u test.gnu # what follows is the reply
     test.gnu:
     Got `A' record: 217.92.15.146

That shows that resolution works, once GNS is integrated with the
application.


File: gnunet.info,  Node: Integration with Browsers,  Next: Creating a Business Card,  Prev: Resolving GNS records,  Up: First steps - Using the GNU Name System

5.2.6 Integration with Browsers
-------------------------------

While we recommend integrating GNS using the NSS module in the GNU libc
Name Service Switch, you can also integrate GNS directly with your
browser via the `gnunet-gns-proxy'.  This method can have the advantage
that the proxy can validate TLS/X.509 records and thus strengthen web
security; however, the proxy is still a bit brittle, so expect subtle
failures. We have had reasonable success with Chromium, and various
frustrations with Firefox in this area recently.

   The first step is to start the proxy. As the proxy is (usually) not
started by default, this is done as a unprivileged user using
`gnunet-arm -i gns-proxy'. Use `gnunet-arm -I' as a unprivileged user
to check that the proxy was actually started. (The most common error
for why the proxy may fail to start is that you did not run
`gnunet-gns-proxy-setup-ca' during installation.) The proxy is a SOCKS5
proxy running (by default) on port 7777. Thus, you need to now
configure your browser to use this proxy. With Chromium, you can do
this by starting the browser as a unprivileged user using `chromium
--proxy-server="socks5://localhost:7777"' For `Firefox' (or `Icecat'),
select "Edit-Preferences" in the menu, and then select the "Advanced"
tab in the dialog and then "Network":

   Here, select "Settings..." to open the proxy settings dialog.
Select "Manual proxy configuration" and enter `localhost' with port
7777 under SOCKS Host.  Furthermore, set the checkbox "Proxy DNS when
using SOCKS v5" at the bottom of the dialog.  Finally, push "OK".

   You must also go to about:config and change the
`browser.fixup.alternate.enabled' option to `false', otherwise the
browser will autoblunder an address like `www.gnu (http://www.gnu/)' to
`www.gnu.com (http://www.gnu.com/)'.  If you want to resolve @ in your
own TLDs, you must additionally set
`browser.fixup.dns_first_use_for_single_words' to `true'.

   After configuring your browser, you might want to first confirm that
it continues to work as before. (The proxy is still experimental and if
you experience "odd" failures with some webpages, you might want to
disable it again temporarily.) Next, test if things work by typing
"`http://test.gnu/'" into the URL bar of your browser.  This currently
fails with (my version of) Firefox as Firefox is super-smart and tries
to resolve "`http://www.test.gnu/'" instead of "`test.gnu'". Chromium
can be convinced to comply if you explicitly include the "http://"
prefix -- otherwise a Google search might be attempted, which is not
what you want. If successful, you should see a simple website.

   Note that while you can use GNS to access ordinary websites, this is
more an experimental feature and not really our primary goal at this
time. Still, it is a possible use-case and we welcome help with testing
and development.


File: gnunet.info,  Node: Creating a Business Card,  Next: Be Social,  Prev: Integration with Browsers,  Up: First steps - Using the GNU Name System

5.2.7 Creating a Business Card
------------------------------

Before we can really use GNS, you should create a business card.  Note
that this requires having `LaTeX' installed on your system.  If you are
using a Debian GNU/Linux based operating system, the following command
should install the required components.  Keep in mind that this
requires 3GB of downloaded data and possibly even more when unpacked.
On a GNU Guix based system texlive 2017 has returns a DAG size of
5032.4 MiB.  We welcome any help in identifying the required components
of the TexLive Distribution. This way we could just state the required
components without pulling in the full distribution of TexLive.

     apt-get install texlive-full

Start creating a business card by clicking the "Copy" button in
`gnunet-namestore-gtk'. Next, you should start the `gnunet-bcd' program
(in the terminal, on the command-line).  You do not need to pass any
options, and please be not surprised if there is no output:

     $ gnunet-bcd # seems to hang...

Then, start a browser and point it to `http://localhost:8888/' where
`gnunet-bcd' is running a Web server!

   First, you might want to fill in the "GNS Public Key" field by
right-clicking and selecting "Paste", filling in the public key from
the copy you made in `gnunet-namestore-gtk'.  Then, fill in all of the
other fields, including your GNS NICKname.  Adding a GPG fingerprint is
optional.  Once finished, click "Submit Query".  If your `LaTeX'
installation is incomplete, the result will be disappointing.
Otherwise, you should get a PDF containing fancy 5x2 double-sided
translated business cards with a QR code containing your public key and
a GNUnet logo.  We'll explain how to use those a bit later.  You can
now go back to the shell running `gnunet-bcd' and press CTRL-C to shut
down the Web server.


File: gnunet.info,  Node: Be Social,  Next: Backup of Identities and Egos,  Prev: Creating a Business Card,  Up: First steps - Using the GNU Name System

5.2.8 Be Social
---------------

Next, you should print out your business card and be social.  Find a
friend, help them install GNUnet and exchange business cards with them.
Or, if you're a desperate loner, you might try the next step with your
own card. Still, it'll be hard to have a conversation with yourself
later, so it would be better if you could find a friend.  You might
also want a camera attached to your computer, so you might need a trip
to the store together.

   Before we get started, we need to tell `gnunet-qr' which zone it
should import new records into.  For this, run:

     $ gnunet-identity -s namestore -e NAME
   where NAME is the name of the zone you want to import records into.
In our running example, this would be "gnu".

   Henceforth, for every business card you collect, simply run:
     $ gnunet-qr

to open a window showing whatever your camera points at.  Hold up your
friend's business card and tilt it until the QR code is recognized. At
that point, the window should automatically close. At that point, your
friend's NICKname and their public key should have been automatically
imported into your zone.

   Assuming both of your peers are properly integrated in the GNUnet
network at this time, you should thus be able to resolve your friends
names. Suppose your friend's nickname is "Bob". Then, type

     $ gnunet-gns -u test.bob.gnu

to check if your friend was as good at following instructions as you
were.


File: gnunet.info,  Node: Backup of Identities and Egos,  Next: Revocation,  Prev: Be Social,  Up: First steps - Using the GNU Name System

5.2.9 Backup of Identities and Egos
-----------------------------------

One should always backup their files, especially in these SSD days (our
team has suffered 3 SSD crashes over a span of 2 weeks). Backing up peer
identity and zones is achieved by copying the following files:

   The peer identity file can be found in
`~/.local/share/gnunet/private_key.ecc'

   The private keys of your egos are stored in the directory
`~/.local/share/gnunet/identity/egos/'.  They are stored in files whose
filenames correspond to the zones' ego names.  These are probably the
most important files you want to backup from a GNUnet installation.

   Note: All these files contain cryptographic keys and they are stored
without any encryption.  So it is advisable to backup encrypted copies
of them.


File: gnunet.info,  Node: Revocation,  Next: What's Next?,  Prev: Backup of Identities and Egos,  Up: First steps - Using the GNU Name System

5.2.10 Revocation
-----------------

Now, in the situation of an attacker gaining access to the private key
of one of your egos, the attacker can create records in the respective
GNS zone and publish them as if you published them.  Anyone resolving
your domain will get these new records and when they verify they seem
authentic because the attacker has signed them with your key.

   To address this potential security issue, you can pre-compute a
revocation certificate corresponding to your ego.  This certificate,
when published on the P2P network, flags your private key as invalid,
and all further resolutions or other checks involving the key will fail.

   A revocation certificate is thus a useful tool when things go out of
control, but at the same time it should be stored securely.  Generation
of the revocation certificate for a zone can be done through
`gnunet-revocation'. For example, the following command (as
unprivileged user) generates a revocation file `revocation.dat' for the
zone `zone1': `gnunet-revocation -f revocation.dat -R zone1'

   The above command only pre-computes a revocation certificate.  It
does not revoke the given zone.  Pre-computing a revocation certificate
involves computing a proof-of-work and hence may take up to 4 to 5 days
on a modern processor.  Note that you can abort and resume the
calculation at any time. Also, even if you did not finish the
calculation, the resulting file will contain the signature, which is
sufficient to complete the revocation process even without access to
the private key.  So instead of waiting for a few days, you can just
abort with CTRL-C, backup the revocation certificate and run the
calculation only if your key actually was compromised. This has the
disadvantage of revocation taking longer after the incident, but the
advantage of saving a significant amount of energy.  So unless you
believe that a key compromise will need a rapid response, we urge you
to wait with generating the revocation certificate.  Also, the
calculation is deliberately expensive, to deter people from doing this
just for fun (as the actual revocation operation is expensive for the
network, not for the peer performing the revocation).

   To avoid TL;DR ones from accidentally revocating their zones, we are
not giving away the command, but it is uncomplicated: the actual
revocation is performed by using the `-p' option of `gnunet-revocation'.


File: gnunet.info,  Node: What's Next?,  Prev: Revocation,  Up: First steps - Using the GNU Name System

5.2.11 What's Next?
-------------------

This may seem not like much of an application yet, but you have just
been one of the first to perform a decentralized secure name lookup
(where nobody could have altered the value supplied by your friend) in
a privacy-preserving manner (your query on the network and the
corresponding response were always encrypted). So what can you really
do with this? Well, to start with, you can publish your GnuPG
fingerprint in GNS as a "CERT" record and replace the public
web-of-trust with its complicated trust model with explicit names and
privacy-preserving resolution. Also, you should read the next chapter
of the tutorial and learn how to use GNS to have a private conversation
with your friend. Finally, help us with the next GNUnet release for
even more applications using this new public key infrastructure.


File: gnunet.info,  Node: First steps - Using GNUnet Conversation,  Next: First steps - Using the GNUnet VPN,  Prev: First steps - Using the GNU Name System,  Up: Using GNUnet

5.3 First steps - Using GNUnet Conversation
===========================================

First, you should launch the graphical user interface.  You can do this
from the command-line by typing

     $ gnunet-conversation-gtk

* Menu:

* Testing your Audio Equipment::
* GNS Zones::


File: gnunet.info,  Node: Testing your Audio Equipment,  Next: GNS Zones,  Up: First steps - Using GNUnet Conversation

5.3.1 Testing your Audio Equipment
----------------------------------

First, you should use `gnunet-conversation-test' to check that your
microphone and speaker are working correctly. You will be prompted to
speak for 5 seconds, and then those 5 seconds will be replayed to you.
The network is not involved in this test. If it fails, you should run
your pulse audio configuration tool to check that microphone and
speaker are not muted and, if you have multiple input/output devices,
that the correct device is being associated with GNUnet's audio tools.


File: gnunet.info,  Node: GNS Zones,  Prev: Testing your Audio Equipment,  Up: First steps - Using GNUnet Conversation

5.3.2 GNS Zones
---------------

`gnunet-conversation' uses GNS for addressing. This means that you need
to have a GNS zone created before using it. Information about how to
create GNS zones can be found here.

* Menu:

* Picking an Identity::
* Calling somebody::


File: gnunet.info,  Node: Picking an Identity,  Next: Calling somebody,  Up: GNS Zones

5.3.2.1 Picking an Identity
...........................

To make a call with `gnunet-conversation', you first need to choose an
identity. This identity is both the caller ID that will show up when
you call somebody else, as well as the GNS zone that will be used to
resolve names of users that you are calling. Run

     gnunet-conversation -e zone-name

to start the command-line tool. You will see a message saying that your
phone is now "active on line 0". You can connect multiple phones on
different lines at the same peer. For the first phone, the line zero is
of course a fine choice.

   Next, you should type in `/help' for a list of available commands.
We will explain the important ones during this tutorial. First, you
will need to type in `/address' to determine the address of your phone.
The result should look something like this:

     /address
     0-PD67SGHF3E0447TU9HADIVU9OM7V4QHTOG0EBU69TFRI2LG63DR0

Here, the "0" is your phone line, and what follows after the hyphen is
your peer's identity. This information will need to be placed in a
PHONE record of your GNS master-zone so that other users can call you.

   Start `gnunet-namestore-gtk' now (possibly from another shell) and
create an entry home-phone in your master zone.  For the record type,
select PHONE. You should then see the PHONE dialog:

 [image src="images/gnunet-namestore-gtk-phone.png" alt="Dialog to publish a PHONE record" ]

   Note: Do not choose the expiry time to be 'Never'. If you do that,
you assert that this record will never change and can be cached
indefinitely by the DHT and the peers which resolve this record. A
reasonable period is 1 year.

   Enter your peer identity under Peer and leave the line at zero.
Select the first option to make the record public.  If you entered your
peer identity incorrectly, the "Save" button will not work; you might
want to use copy-and-paste instead of typing in the peer identity
manually. Save the record.


File: gnunet.info,  Node: Calling somebody,  Prev: Picking an Identity,  Up: GNS Zones

5.3.2.2 Calling somebody
........................

Now you can call a buddy. Obviously, your buddy will have to have GNUnet
installed and must have performed the same steps. Also, you must have
your buddy in your GNS master zone, for example by having imported your
buddy's public key using `gnunet-qr'. Suppose your buddy is in your
zone as `buddy.mytld' and they also created their phone using a label
"home-phone". Then you can initiate a call using:

     /call home-phone.buddy.mytld

   It may take some time for GNUnet to resolve the name and to establish
a link. If your buddy has your public key in their master zone, they
should see an incoming call with your name. If your public key is not
in their master zone, they will just see the public key as the caller
ID.

   Your buddy then can answer the call using the "/accept" command.
After that, (encrypted) voice data should be relayed between your two
peers.  Either of you can end the call using `/cancel'. You can exit
`gnunet-conversation' using `/quit'.


File: gnunet.info,  Node: First steps - Using the GNUnet VPN,  Next: File-sharing,  Prev: First steps - Using GNUnet Conversation,  Up: Using GNUnet

5.4 First steps - Using the GNUnet VPN
======================================

* Menu:

* VPN Preliminaries::
* GNUnet-Exit configuration::
* GNS configuration::
* Accessing the service::
* Using a Browser::


File: gnunet.info,  Node: VPN Preliminaries,  Next: GNUnet-Exit configuration,  Up: First steps - Using the GNUnet VPN

5.4.1 VPN Preliminaries
-----------------------

To test the GNUnet VPN, we should first run a web server.  The easiest
way to do this is to just start `gnunet-bcd', which will run a
webserver on port `8888' by default.  Naturally, you can run some other
HTTP server for our little tutorial.

   If you have not done this, you should also configure your Name
System Service switch to use GNS. In your `/etc/nsswitch.conf' you
should fine a line like this:

     hosts: files mdns4_minimal [NOTFOUND=return] dns mdns4

The exact details may differ a bit, which is fine. Add the text `gns
[NOTFOUND=return]' after `files':

     hosts: files gns [NOTFOUND=return] mdns4_minimal [NOTFOUND=return] dns mdns4

You might want to make sure that `/lib/libnss_gns.so.2' exists on your
system, it should have been created during the installation.  If not,
re-run

     $ configure --with-nssdir=/lib
     $ cd src/gns/nss; sudo make install

to install the NSS plugins in the proper location.


File: gnunet.info,  Node: GNUnet-Exit configuration,  Next: GNS configuration,  Prev: VPN Preliminaries,  Up: First steps - Using the GNUnet VPN

5.4.2 GNUnet-Exit configuration
-------------------------------

Stop your peer (as user `gnunet', run `gnunet-arm -e') and run
`gnunet-setup'. In `gnunet-setup', make sure to activate the *EXIT* and
*GNS* services in the General tab.  Then select the Exit tab. Most of
the defaults should be fine (but you should check against the
screenshot that they have not been modified).  In the bottom area,
enter `bcd' under Identifier and change the Destination to
`169.254.86.1:8888' (if your server runs on a port other than 8888,
change the 8888 port accordingly).

   Now exit `gnunet-setup' and restart your peer (`gnunet-arm -s').


File: gnunet.info,  Node: GNS configuration,  Next: Accessing the service,  Prev: GNUnet-Exit configuration,  Up: First steps - Using the GNUnet VPN

5.4.3 GNS configuration
-----------------------

Now, using your normal user (not the `gnunet' system user), run
`gnunet-namestore-gtk'. Add a new label www in your master zone. For
the record type, select `VPN'. You should then see the VPN dialog:

 [image src="images/gnunet-namestore-gtk-vpn.png" alt="Dialog to publish a VPN record" ]

   Under peer, you need to supply the peer identity of your own peer.
You can obtain the respective string by running `gnunet-peerinfo -sq'
as the `gnunet' user. For the Identifier, you need to supply the same
identifier that we used in the Exit setup earlier, so here supply "bcd".
If you want others to be able to use the service, you should probably
make the record public. For non-public services, you should use a
passphrase instead of the string "bcd". Save the record and exit
`gnunet-namestore-gtk'.


File: gnunet.info,  Node: Accessing the service,  Next: Using a Browser,  Prev: GNS configuration,  Up: First steps - Using the GNUnet VPN

5.4.4 Accessing the service
---------------------------

You should now be able to access your webserver. Type in:

     $ wget http://www.gnu/

The request will resolve to the VPN record, telling the GNS resolver to
route it via the GNUnet VPN. The GNS resolver will ask the GNUnet VPN
for an IPv4 address to return to the application. The VPN service will
use the VPN information supplied by GNS to create a tunnel (via
GNUnet's MESH service) to the EXIT peer.  At the EXIT, the name "bcd"
and destination port (80) will be mapped to the specified destination
IP and port. While all this is currently happening on just the local
machine, it should also work with other peers -- naturally, they will
need a way to access your GNS zone first, for example by learning your
public key from a QR code on your business card.


File: gnunet.info,  Node: Using a Browser,  Prev: Accessing the service,  Up: First steps - Using the GNUnet VPN

5.4.5 Using a Browser
---------------------

Sadly, modern browsers tend to bypass the Name Services Switch and
attempt DNS resolution directly. You can either run a `gnunet-dns2gns'
DNS proxy, or point the browsers to an HTTP proxy. When we tried it,
Iceweasel did not like to connect to the socks proxy for `.gnu' TLDs,
even if we disabled its autoblunder of changing `.gnu' to ".gnu.com".
Still, using the HTTP proxy with Chrome does work.


File: gnunet.info,  Node: File-sharing,  Next: The GNU Name System,  Prev: First steps - Using the GNUnet VPN,  Up: Using GNUnet

5.5 File-sharing
================

This chapter documents the GNUnet file-sharing application. The original
file-sharing implementation for GNUnet was designed to provide
*anonymous* file-sharing. However, over time, we have also added
support for non-anonymous file-sharing (which can provide better
performance). Anonymous and non-anonymous file-sharing are quite
integrated in GNUnet and, except for routing, share most of the concepts
and implementation. There are three primary file-sharing operations:
publishing, searching and downloading. For each of these operations,
the user specifies an *anonymity level*. If both the publisher and the
searcher/downloader specify "no anonymity", non-anonymous file-sharing
is used. If either user specifies some desired degree of anonymity,
anonymous file-sharing will be used.

   After a short introduction, we will first look at the various
concepts in GNUnet's file-sharing implementation. Then, we will discuss
specifics as to how they impact users that publish, search or download
files.

* Menu:

* fs-Searching::
* fs-Downloading::
* fs-Publishing::
* fs-Concepts::
* Namespace Management::
* File-Sharing URIs::
* GTK User Interface::


File: gnunet.info,  Node: fs-Searching,  Next: fs-Downloading,  Up: File-sharing

5.5.1 Searching
---------------

The command `gnunet-search' can be used to search for content on
GNUnet. The format is:

     $ gnunet-search [-t TIMEOUT] KEYWORD

The `-t' option specifies that the query should timeout after
approximately TIMEOUT seconds. A value of zero ("0") is interpreted as
_no timeout_, which is the default. In this case, `gnunet-search' will
never terminate (unless you press `CTRL-C').

   If multiple words are passed as keywords, they will all be
considered optional. Prefix keywords with a "+" to make them mandatory.

   Note that searching using

     $ gnunet-search Das Kapital

is not the same as searching for

     $ gnunet-search "Das Kapital"

as the first will match files shared under the keywords "Das" or
"Kapital" whereas the second will match files shared under the keyword
"Das Kapital".

   Search results are printed by `gnunet-search' like this:

     #15:
     gnunet-download -o "COPYING" gnunet://fs/chk/PGK8M...3EK130.75446

The whole line is the command you would have to enter to download the
file. The first argument passed to `-o' is the suggested filename (you
may change it to whatever you like).  It is followed by the key for
decrypting the file, the query for searching the file, a checksum (in
hexadecimal) finally the size of the file in bytes.


File: gnunet.info,  Node: fs-Downloading,  Next: fs-Publishing,  Prev: fs-Searching,  Up: File-sharing

5.5.2 Downloading
-----------------

In order to download a file, you need the whole line returned by
`gnunet-search'.  You can then use the tool `gnunet-download' to obtain
the file:

     $ gnunet-download -o <FILENAME> <GNUNET-URL>

FILENAME specifies the name of the file where GNUnet is supposed to
write the result. Existing files are overwritten. If the existing file
contains blocks that are identical to the desired download, those
blocks will not be downloaded again (automatic resume).

   If you want to download the GPL from the previous example, you do
the following:

     $ gnunet-download -o "COPYING" gnunet://fs/chk/PGK8M...3EK130.75446

If you ever have to abort a download, you can continue it at any time by
re-issuing `gnunet-download' with the same filename.  In that case,
GNUnet will *not* download blocks again that are already present.

   GNUnet's file-encoding mechanism will ensure file integrity, even if
the existing file was not downloaded from GNUnet in the first place.

   You may want to use the `-V' switch to turn on verbose reporting. In
this case, `gnunet-download' will print the current number of bytes
downloaded whenever new data was received.


File: gnunet.info,  Node: fs-Publishing,  Next: fs-Concepts,  Prev: fs-Downloading,  Up: File-sharing

5.5.3 Publishing
----------------

The command `gnunet-publish' can be used to add content to the network.
The basic format of the command is

     $ gnunet-publish [-n] [-k KEYWORDS]* [-m TYPE:VALUE] FILENAME

   For example
     $ gnunet-publish -m "description:GNU License" -k gpl -k test -m "mimetype:text/plain" COPYING

* Menu:

* Important command-line options::
* Indexing vs. Inserting::


File: gnunet.info,  Node: Important command-line options,  Next: Indexing vs. Inserting,  Up: fs-Publishing

5.5.3.1 Important command-line options
......................................

The option `-k' is used to specify keywords for the file that should be
inserted. You can supply any number of keywords, and each of the
keywords will be sufficient to locate and retrieve the file. Please
note that you must use the `-k' option more than once - one for each
expression you use as a keyword for the filename.

   The -m option is used to specify meta-data, such as descriptions.
You can use -m multiple times. The TYPE passed must be from the list of
meta-data types known to libextractor. You can obtain this list by
running `extract -L'. Use quotes around the entire meta-data argument
if the value contains spaces. The meta-data is displayed to other users
when they select which files to download. The meta-data and the
keywords are optional and may be inferred using `GNU libextractor'.

   `gnunet-publish' has a few additional options to handle namespaces
and directories. Refer to the man-page for details:

     man gnunet-publish


File: gnunet.info,  Node: Indexing vs. Inserting,  Prev: Important command-line options,  Up: fs-Publishing

5.5.3.2 Indexing vs Inserting
.............................

By default, GNUnet indexes a file instead of making a full copy.  This
is much more efficient, but requires the file to stay unaltered at the
location where it was when it was indexed. If you intend to move,
delete or alter a file, consider using the option `-n' which will force
GNUnet to make a copy of the file in the database.

   Since it is much less efficient, this is strongly discouraged for
large files. When GNUnet indexes a file (default), GNUnet does *not*
create an additional encrypted copy of the file but just computes a
summary (or index) of the file. That summary is approximately two
percent of the size of the original file and is stored in GNUnet's
database.  Whenever a request for a part of an indexed file reaches
GNUnet, this part is encrypted on-demand and send out. This way, there
is no need for an additional encrypted copy of the file to stay anywhere
on the drive. This is different from other systems, such as Freenet,
where each file that is put online must be in Freenet's database in
encrypted format, doubling the space requirements if the user wants to
preserve a directly accessible copy in plaintext.

   Thus indexing should be used for all files where the user will keep
using this file (at the location given to gnunet-publish) and does not
want to retrieve it back from GNUnet each time. If you want to remove a
file that you have indexed from the local peer, use the tool
`gnunet-unindex' to un-index the file.

   The option `-n' may be used if the user fears that the file might be
found on their drive (assuming the computer comes under the control of
an adversary). When used with the `-n' flag, the user has a much better
chance of denying knowledge of the existence of the file, even if it is
still (encrypted) on the drive and the adversary is able to crack the
encryption (e.g. by guessing the keyword.


File: gnunet.info,  Node: fs-Concepts,  Next: Namespace Management,  Prev: fs-Publishing,  Up: File-sharing

5.5.4 Concepts
--------------

For better results with filesharing it is useful to understand the
following concepts.  In addition to anonymous routing GNUnet attempts
to give users a better experience in searching for content. GNUnet uses
cryptography to safely break content into smaller pieces that can be
obtained from different sources without allowing participants to
corrupt files. GNUnet makes it difficult for an adversary to send back
bogus search results. GNUnet enables content providers to group related
content and to establish a reputation. Furthermore, GNUnet allows
updates to certain content to be made available. This section is
supposed to introduce users to the concepts that are used to achieve
these goals.

* Menu:

* Files::
* Keywords::
* Directories::
* Egos and File-Sharing::
* Namespaces::
* Advertisements::
* Anonymity level::
* Content Priority::
* Replication::


File: gnunet.info,  Node: Files,  Next: Keywords,  Up: fs-Concepts

5.5.4.1 Files
.............

A file in GNUnet is just a sequence of bytes. Any file-format is allowed
and the maximum file size is theoretically 2^64 - 1 bytes, except that
it would take an impractical amount of time to share such a file.
GNUnet itself never interprets the contents of shared files, except when
using GNU libextractor to obtain keywords.


File: gnunet.info,  Node: Keywords,  Next: Directories,  Prev: Files,  Up: fs-Concepts

5.5.4.2 Keywords
................

Keywords are the most simple mechanism to find files on GNUnet.
Keywords are *case-sensitive* and the search string must always match
*exactly* the keyword used by the person providing the file. Keywords
are never transmitted in plaintext. The only way for an adversary to
determine the keyword that you used to search is to guess it (which
then allows the adversary to produce the same search request). Since
providing keywords by hand for each shared file is tedious, GNUnet uses
GNU libextractor to help automate this process. Starting a keyword
search on a slow machine can take a little while since the keyword
search involves computing a fresh RSA key to formulate the request.


File: gnunet.info,  Node: Directories,  Next: Egos and File-Sharing,  Prev: Keywords,  Up: fs-Concepts

5.5.4.3 Directories
...................

A directory in GNUnet is a list of file identifiers with meta data.
The file identifiers provide sufficient information about the files to
allow downloading the contents. Once a directory has been created, it
cannot be changed since it is treated just like an ordinary file by the
network. Small files (of a few kilobytes) can be inlined in the
directory, so that a separate download becomes unnecessary.

   Directories are shared just like ordinary files. If you download a
directory with `gnunet-download', you can use `gnunet-directory' to
list its contents. The canonical extension for GNUnet directories when
stored as files in your local file-system is ".gnd". The contents of a
directory are URIs and meta data.  The URIs contain all the information
required by `gnunet-download' to retrieve the file. The meta data
typically includes the mime-type, description, a filename and other
meta information, and possibly even the full original file (if it was
small).


File: gnunet.info,  Node: Egos and File-Sharing,  Next: Namespaces,  Prev: Directories,  Up: fs-Concepts

5.5.4.4 Egos and File-Sharing
.............................

When sharing files, it is sometimes desirable to build a reputation as
a source for quality information.  With egos, publishers can
(cryptographically) sign files, thereby demonstrating that various
files were published by the same entity.  An ego thus allows users to
link different publication events, thereby deliberately reducing
anonymity to pseudonymity.

   Egos used in GNUnet's file-sharing for such pseudonymous publishing
also correspond to the egos used to identify and sign zones in the GNU
Name System.  However, if the same ego is used for file-sharing and for
a GNS zone, this will weaken the privacy assurances provided by the
anonymous file-sharing protocol.

   Note that an ego is NOT bound to a GNUnet peer. There can be multiple
egos for a single user, and users could (theoretically) share the
private keys of an ego by copying the respective private keys.


File: gnunet.info,  Node: Namespaces,  Next: Advertisements,  Prev: Egos and File-Sharing,  Up: fs-Concepts

5.5.4.5 Namespaces
..................

A namespace is a set of files that were signed by the same ego.  Today,
namespaces are implemented independently of GNS zones, but in the
future we plan to merge the two such that a GNS zone can basically
contain files using a file-sharing specific record type.

   Files (or directories) that have been signed and placed into a
namespace can be updated. Updates are identified as authentic if the
same secret key was used to sign the update.


File: gnunet.info,  Node: Advertisements,  Next: Anonymity level,  Prev: Namespaces,  Up: fs-Concepts

5.5.4.6 Advertisements
......................

Advertisements are used to notify other users about the existence of a
namespace. Advertisements are propagated using the normal keyword
search.  When an advertisement is received (in response to a search),
the namespace is added to the list of namespaces available in the
namespace-search dialogs of gnunet-fs-gtk and printed by
`gnunet-identity'. Whenever a namespace is created, an appropriate
advertisement can be generated.  The default keyword for the
advertising of namespaces is "namespace".


File: gnunet.info,  Node: Anonymity level,  Next: Content Priority,  Prev: Advertisements,  Up: fs-Concepts

5.5.4.7 Anonymity level
.......................

The anonymity level determines how hard it should be for an adversary to
determine the identity of the publisher or the searcher/downloader. An
anonymity level of zero means that anonymity is not required. The
default anonymity level of "1" means that anonymous routing is desired,
but no particular amount of cover traffic is necessary. A powerful
adversary might thus still be able to deduce the origin of the traffic
using traffic analysis. Specifying higher anonymity levels increases the
amount of cover traffic required.

   The specific numeric value (for anonymity levels above 1) is simple:
Given an anonymity level L (above 1), each request FS makes on your
behalf must be hidden in L-1 equivalent requests of cover traffic
(traffic your peer routes for others) in the same time-period.  The
time-period is twice the average delay by which GNUnet artificially
delays traffic.

   While higher anonymity levels may offer better privacy, they can also
significantly hurt performance.


File: gnunet.info,  Node: Content Priority,  Next: Replication,  Prev: Anonymity level,  Up: fs-Concepts

5.5.4.8 Content Priority
........................

Depending on the peer's configuration, GNUnet peers migrate content
between peers. Content in this sense are individual blocks of a file,
not necessarily entire files. When peers run out of space (due to local
publishing operations or due to migration of content from other peers),
blocks sometimes need to be discarded. GNUnet first always discards
expired blocks (typically, blocks are published with an expiration of
about two years in the future; this is another option).  If there is
still not enough space, GNUnet discards the blocks with the lowest
priority. The priority of a block is decided by its popularity (in
terms of requests from peers we trust) and, in case of blocks published
locally, the base-priority that was specified by the user when the
block was published initially.


File: gnunet.info,  Node: Replication,  Prev: Content Priority,  Up: fs-Concepts

5.5.4.9 Replication
...................

When peers migrate content to other systems, the replication level of a
block is used to decide which blocks need to be migrated most urgently.
GNUnet will always push the block with the highest replication level
into the network, and then decrement the replication level by one. If
all blocks reach replication level zero, the selection is simply random.


File: gnunet.info,  Node: Namespace Management,  Next: File-Sharing URIs,  Prev: fs-Concepts,  Up: File-sharing

5.5.5 Namespace Management
--------------------------

The `gnunet-identity' tool can be used to create egos.  By default,
`gnunet-identity -D' simply lists all locally available egos.

* Menu:

* Creating Egos::
* Deleting Egos::


File: gnunet.info,  Node: Creating Egos,  Next: Deleting Egos,  Up: Namespace Management

5.5.5.1 Creating Egos
.....................

With the `-C NICK' option it can also be used to create a new ego. An
ego is the virtual identity of the entity in control of a namespace or
GNS zone. Anyone can create any number of egos.  The provided NICK name
automatically corresponds to a GNU Name System domain name.  Thus,
henceforth name resolution for any name ending in ".NICK" will use the
NICK's zone.  You should avoid using NICKs that collide with well-known
DNS names.


File: gnunet.info,  Node: Deleting Egos,  Prev: Creating Egos,  Up: Namespace Management

5.5.5.2 Deleting Egos
.....................

With the `-D NICK' option egos can be deleted.  Once the ego has been
deleted it is impossible to add content to the corresponding namespace
or zone. However, the existing GNS zone data is currently not dropped.
This may change in the future.

   Deleting the pseudonym does not make the namespace or any content in
it unavailable.


File: gnunet.info,  Node: File-Sharing URIs,  Next: GTK User Interface,  Prev: Namespace Management,  Up: File-sharing

5.5.6 File-Sharing URIs
-----------------------

GNUnet (currently) uses four different types of URIs for file-sharing.
They all begin with "gnunet://fs/".  This section describes the four
different URI types in detail.

   For FS URIs empty KEYWORDs are not allowed. Quotes are allowed to
denote whitespace between words. Keywords must contain a balanced
number of double quotes. Doubles quotes can not be used in the actual
keywords. This means that the string '""foo bar""' will be turned into
two OR-ed keywords 'foo' and 'bar', not into '"foo bar"'.

* Menu:

* Encoding of hash values in URIs::
* Content Hash Key (chk)::
* Location identifiers (loc)::
* Keyword queries (ksk)::
* Namespace content (sks)::


File: gnunet.info,  Node: Encoding of hash values in URIs,  Next: Content Hash Key (chk),  Up: File-Sharing URIs

5.5.6.1 Encoding of hash values in URIs
.......................................

Most URIs include some hash values. Hashes are encoded using base32hex
(RFC 2938).


File: gnunet.info,  Node: Content Hash Key (chk),  Next: Location identifiers (loc),  Prev: Encoding of hash values in URIs,  Up: File-Sharing URIs

5.5.6.2 Content Hash Key (chk)
..............................

A chk-URI is used to (uniquely) identify a file or directory and to
allow peers to download the file. Files are stored in GNUnet as a tree
of encrypted blocks.  The chk-URI thus contains the information to
download and decrypt those blocks. A chk-URI has the format
"gnunet://fs/chk/KEYHASH.QUERYHASH.SIZE". Here, "SIZE" is the size of
the file (which allows a peer to determine the shape of the tree),
KEYHASH is the key used to decrypt the file (also the hash of the
plaintext of the top block) and QUERYHASH is the query used to request
the top-level block (also the hash of the encrypted block).


File: gnunet.info,  Node: Location identifiers (loc),  Next: Keyword queries (ksk),  Prev: Content Hash Key (chk),  Up: File-Sharing URIs

5.5.6.3 Location identifiers (loc)
..................................

For non-anonymous file-sharing, loc-URIs are used to specify which peer
is offering the data (in addition to specifying all of the data from a
chk-URI). Location identifiers include a digital signature of the peer
to affirm that the peer is truly the origin of the data. The format is
"gnunet://fs/loc/KEYHASH.QUERYHASH.SIZE.PEER.SIG.EXPTIME".  Here,
"PEER" is the public key of the peer (in GNUnet format in base32hex),
SIG is the RSA signature (in GNUnet format in base32hex) and EXPTIME
specifies when the signature expires (in milliseconds after 1970).


File: gnunet.info,  Node: Keyword queries (ksk),  Next: Namespace content (sks),  Prev: Location identifiers (loc),  Up: File-Sharing URIs

5.5.6.4 Keyword queries (ksk)
.............................

A keyword-URI is used to specify that the desired operation is the
search using a particular keyword. The format is simply
"gnunet://fs/ksk/KEYWORD". Non-ASCII characters can be specified using
the typical URI-encoding (using hex values) from HTTP.  "+" can be used
to specify multiple keywords (which are then logically "OR"-ed in the
search, results matching both keywords are given a higher rank):
"gnunet://fs/ksk/KEYWORD1+KEYWORD2".  ksk-URIs must not begin or end
with the plus ('+') character.  Furthermore they must not contain '++'.


File: gnunet.info,  Node: Namespace content (sks),  Prev: Keyword queries (ksk),  Up: File-Sharing URIs

5.5.6.5 Namespace content (sks)
...............................

Please note that the text in this subsection is outdated and needs to
be rewritten for version 0.10!  This especially concerns the
terminology of Pseudonym/Ego/Identity.

   Namespaces are sets of files that have been approved by some (usually
pseudonymous) user -- typically by that user publishing all of the
files together. A file can be in many namespaces. A file is in a
namespace if the owner of the ego (aka the namespace's private key)
signs the CHK of the file cryptographically. An SKS-URI is used to
search a namespace. The result is a block containing meta data, the CHK
and the namespace owner's signature. The format of a sks-URI is
"gnunet://fs/sks/NAMESPACE/IDENTIFIER". Here, "NAMESPACE" is the public
key for the namespace. "IDENTIFIER" is a freely chosen keyword (or
password!). A commonly used identifier is "root" which by convention
refers to some kind of index or other entry point into the namespace.


File: gnunet.info,  Node: GTK User Interface,  Prev: File-Sharing URIs,  Up: File-sharing

5.5.7 GTK User Interface
------------------------

This chapter describes first steps for file-sharing with GNUnet.  To
start, you should launch `gnunet-fs-gtk'.

   As we want to be sure that the network contains the data that we are
looking for for testing, we need to begin by publishing a file.

* Menu:

* gtk-Publishing::
* gtk-Searching::
* gtk-Downloading::


File: gnunet.info,  Node: gtk-Publishing,  Next: gtk-Searching,  Up: GTK User Interface

5.5.7.1 Publishing
..................

To publish a file, select "File Sharing" in the menu bar just below the
"Statistics" icon, and then select "Publish" from the menu.

   Afterwards, the following publishing dialog will appear:

 [image src="images/gnunet-gtk-0-10-fs-publish.png" alt="The gnunet-fs-gtk publishing dialog" ]

   In this dialog, select the "Add File" button. This will open a file
selection dialog:

 [image src="images/gnunet-gtk-0-10-fs-publish-select.png" alt="Dialog to select the file to publish (looks may differ for other Gtk+ versions)" ]

   Now, you should select a file from your computer to be published on
GNUnet. To see more of GNUnet's features later, you should pick a PNG
or JPEG file this time. You can leave all of the other options in the
dialog unchanged. Confirm your selection by pressing the "OK" button in
the bottom right corner. Now, you will briefly see a "Messages..."
dialog pop up, but most likely it will be too short for you to really
read anything. That dialog is showing you progress information as
GNUnet takes a first look at the selected file(s).  For a normal image,
this is virtually instant, but if you later import a larger directory
you might be interested in the progress dialog and potential errors
that might be encountered during processing.  After the progress dialog
automatically disappears, your file should now appear in the publishing
dialog:

 [image src="images/gnunet-gtk-0-10-fs-publish-with-file.png" alt="Publishing dialog with file added" ]

   Now, select the file (by clicking on the file name) and then click
the "Edit" button. This will open the editing dialog:

 [image src="images/gnunet-gtk-0-10-fs-publish-editing.png" alt="Editing meta data of a file to be published" ]

   In this dialog, you can see many details about your file. In the top
left area, you can see meta data extracted about the file, such as the
original filename, the mimetype and the size of the image.  In the top
right, you should see a preview for the image (if GNU libextractor was
installed correctly with the respective plugins). Note that if you do
not see a preview, this is not a disaster, but you might still want to
install more of GNU libextractor in the future. In the bottom left, the
dialog contains a list of keywords. These are the keywords under which
the file will be made available. The initial list will be based on the
extracted meta data.  Additional publishing options are in the right
bottom corner. We will now add an additional keyword to the list of
keywords. This is done by entering the keyword above the keyword list
between the label "Keyword" and the "Add keyword" button. Enter "test"
and select "Add keyword".  Note that the keyword will appear at the
bottom of the existing keyword list, so you might have to scroll down
to see it. Afterwards, push the "OK" button at the bottom right of the
dialog.

   You should now be back at the "Publish content on GNUnet" dialog.
Select "Execute" in the bottom right to close the dialog and publish
your file on GNUnet! Afterwards, you should see the main dialog with a
new area showing the list of published files (or ongoing publishing
operations with progress indicators).


File: gnunet.info,  Node: gtk-Searching,  Next: gtk-Downloading,  Prev: gtk-Publishing,  Up: GTK User Interface

5.5.7.2 Searching
.................

Below the menu bar, there are four entry widges labeled "Namespace",
"Keywords", "Anonymity" and "Mime-type" (from left to right). These
widgets are used to control searching for files in GNUnet. Between the
"Keywords" and "Anonymity" widgets, there is also a big "Search" button,
which is used to initiate the search. We will ignore the "Namespace",
"Anonymity" and "Mime-type" options in this tutorial, please leave them
empty. Instead, simply enter "test" under "Keywords" and press "Search".
Afterwards, you should immediately see a new tab labeled after your
search term, followed by the (current) number of search results --
"(15)" in our screenshot. Note that your results may vary depending on
what other users may have shared and how your peer is connected.

   You can now select one of the search results. Once you do this,
additional information about the result should be displayed on the
right. If available, a preview image should appear on the top right.
Meta data describing the file will be listed at the bottom right.

   Once a file is selected, at the bottom of the search result list a
little area for downloading appears.


File: gnunet.info,  Node: gtk-Downloading,  Prev: gtk-Searching,  Up: GTK User Interface

5.5.7.3 Downloading
...................

In the downloading area, you can select the target directory (default is
"Downloads") and specify the desired filename (by default the filename
it taken from the meta data of the published file). Additionally, you
can specify if the download should be anonymous and (for directories) if
the download should be recursive. In most cases, you can simply start
the download with the "Download!" button.

   Once you selected download, the progress of the download will be
displayed with the search result. You may need to resize the result
list or scroll to the right. The "Status" column shows the current
status of the download, and "Progress" how much has been completed.
When you close the search tab (by clicking on the "X" button next to
the "test" label), ongoing and completed downloads are not aborted but
moved to a special "*" tab.

   You can remove completed downloads from the "*" tab by clicking the
cleanup button next to the "*". You can also abort downloads by right
clicking on the respective download and selecting "Abort download" from
the menu.

   That's it, you now know the basics for file-sharing with GNUnet!


File: gnunet.info,  Node: The GNU Name System,  Next: reclaimID Identity Provider,  Prev: File-sharing,  Up: Using GNUnet

5.6 The GNU Name System
=======================

The GNU Name System (GNS) is secure and decentralized naming system.
It allows its users to register names as "top-level domains" (TLDs) and
resolve other namespaces within their TLDs.

   GNS is designed to provide:
   * Censorship resistance

   * Query privacy

   * Secure name resolution

   * Compatibility with DNS

   For the initial configuration and population of your GNS
installation, please follow the GNS setup instructions.  The remainder
of this chapter will provide some background on GNS and then describe
how to use GNS in more detail.

   Unlike DNS, GNS does not rely on central root zones or authorities.
Instead any user administers their own root and can can create arbitrary
name value mappings. Furthermore users can delegate resolution to other
users' zones just like DNS NS records do. Zones are uniquely identified
via public keys and resource records are signed using the corresponding
public key. Delegation to another user's zone is done using special PKEY
records and petnames. A petname is a name that can be freely chosen by
the user. This results in non-unique name-value mappings as
`www.bob.gnu (http://www.bob.gnu/)' to one user might be
`www.friend.gnu (http://www.friend.gnu/)' for someone else.

* Menu:

* Creating a Zone::
* Maintaining your own Zones::
* Obtaining your Zone Key::
* Adding Links to Other Zones::
* Using Public Keys as Top Level Domains::
* Resource Records in GNS::
* Synchronizing with legacy DNS::
* Migrating an existing DNS zone into GNS::


File: gnunet.info,  Node: Creating a Zone,  Next: Maintaining your own Zones,  Up: The GNU Name System

5.6.1 Creating a Zone
---------------------

To use GNS, you probably should create at least one zone of your own.
You can create any number of zones using the gnunet-identity tool using:

     $ gnunet-identity -C "myzone"

   Henceforth, on your system you control the TLD "myzone".

   All of your zones can be listed (displayed) using the
`gnunet-identity' command line tool as well:

     $ gnunet-identity -d


File: gnunet.info,  Node: Maintaining your own Zones,  Next: Obtaining your Zone Key,  Prev: Creating a Zone,  Up: The GNU Name System

5.6.2 Maintaining your own Zones
--------------------------------

Now you can add (or edit, or remove) records in your GNS zone using the
`gnunet-namestore-gtk' GUI or using the `gnunet-namestore' command-line
tool.  In either case, your records will be stored in an SQL database
under control of the `gnunet-service-namestore'.  Note that if multiple
users use one peer, the namestore database will include the combined
records of all users.  However, users will not be able to see each
other's records if they are marked as private.

   To provide a short example for editing your own zone, suppose you
have your own web server with the IP `1.2.3.4'. Then you can put an `A'
record (`A' records in DNS are for IPv4 IP addresses) into your local
zone "myzone" using the command:

     $ gnunet-namestore -z myzone -a -n www -t A -V 1.2.3.4 -e never

Afterwards, you will be able to access your webpage under "www.myzone"
(assuming your webserver does not use virtual hosting, if it does,
please read up on setting up the GNS proxy).

   Similar commands will work for other types of DNS and GNS records,
the syntax largely depending on the type of the record.  Naturally,
most users may find editing the zones using the `gnunet-namestore-gtk'
GUI to be easier.


File: gnunet.info,  Node: Obtaining your Zone Key,  Next: Adding Links to Other Zones,  Prev: Maintaining your own Zones,  Up: The GNU Name System

5.6.3 Obtaining your Zone Key
-----------------------------

Each zone in GNS has a public-private key. Usually, gnunet-namestore and
gnunet-setup will access your private key as necessary, so you do not
have to worry about those. What is important is your public key (or
rather, the hash of your public key), as you will likely want to give
it to others so that they can securely link to you.

   You can usually get the hash of your public key using

     $ gnunet-identity -d $options | grep myzone | awk '{print $3}'

For example, the output might be something like:

     DC3SEECJORPHQNVRH965A6N74B1M37S721IG4RBQ15PJLLPJKUE0

Alternatively, you can obtain a QR code with your zone key AND your
pseudonym from gnunet-namestore-gtk. The QR code is displayed in the
main window and can be stored to disk using the "Save as" button next
to the image.


File: gnunet.info,  Node: Adding Links to Other Zones,  Next: Using Public Keys as Top Level Domains,  Prev: Obtaining your Zone Key,  Up: The GNU Name System

5.6.4 Adding Links to Other Zones
---------------------------------

A central operation in GNS is the ability to securely delegate to other
zones. Basically, by adding a delegation you make all of the names from
the other zone available to yourself. This section describes how to
create delegations.

   Suppose you have a friend who you call 'bob' who also uses GNS.  You
can then delegate resolution of names to Bob's zone by adding a PKEY
record to their local zone:

     $ gnunet-namestore -a -n bob --type PKEY -V XXXX -e never -Z myzone

Note that "XXXX" in the command above must be replaced with the hash of
Bob's public key (the output your friend obtained using the
`gnunet-identity' command from the previous section and told you, for
example by giving you a business card containing this information as a
QR code).

   Assuming Bob has an "A" record for their website under the name of
"www" in his zone, you can then access Bob's website under
"www.bob.myzone" -- as well as any (public) GNS record that Bob has in
their zone by replacing www with the respective name of the record in
Bob's zone.

   Furthermore, if Bob has themselves a (public) delegation to Carol's
zone under "carol", you can access Carol's records under
"NAME.carol.bob.myzone" (where "NAME" is the name of Carol's record you
want to access).


File: gnunet.info,  Node: Using Public Keys as Top Level Domains,  Next: Resource Records in GNS,  Prev: Adding Links to Other Zones,  Up: The GNU Name System

5.6.5 Using Public Keys as Top Level Domains
--------------------------------------------

GNS also assumes responsibility for any name that uses in a well-formed
public key for the TLD.  Names ending this way are then resolved by
querying the respective zone. Such public key TLDs are expected to be
used under rare circumstances where globally unique names are required,
and for integration with legacy systems.


File: gnunet.info,  Node: Resource Records in GNS,  Next: Synchronizing with legacy DNS,  Prev: Using Public Keys as Top Level Domains,  Up: The GNU Name System

5.6.6 Resource Records in GNS
-----------------------------

GNS supports the majority of the DNS records as defined in RFC 1035
(http://www.ietf.org/rfc/rfc1035.txt). Additionally, GNS defines some
new record types the are unique to the GNS system.  For example,
GNS-specific resource records are used to give petnames for zone
delegation, revoke zone keys and provide some compatibility features.

   For some DNS records, GNS does extended processing to increase their
usefulness in GNS. In particular, GNS introduces special names referred
to as "zone relative names". Zone relative names are allowed in some
resource record types (for example, in NS and CNAME records) and can
also be used in links on webpages. Zone relative names end in ".+"
which indicates that the name needs to be resolved relative to the
current authoritative zone. The extended processing of those names will
expand the ".+" with the correct delegation chain to the authoritative
zone (replacing ".+" with the name of the location where the name was
encountered) and hence generate a valid GNS name.

   GNS currently supports the following record types:

* Menu:

* NICK::
* PKEY::
* BOX::
* LEHO::
* VPN::
* A AAAA and TXT::
* CNAME::
* GNS2DNS::
* SOA SRV PTR and MX::
* PLACE::
* PHONE::
* ID ATTR::
* ID TOKEN::
* ID TOKEN METADATA::
* CREDENTIAL::
* POLICY::
* ATTRIBUTE::
* ABE KEY::
* ABE MASTER::
* RECLAIM OIDC CLIENT::
* RECLAIM OIDC REDIRECT::


File: gnunet.info,  Node: NICK,  Next: PKEY,  Up: Resource Records in GNS

5.6.6.1 NICK
............

A NICK record is used to give a zone a name. With a NICK record, you
can essentially specify how you would like to be called. GNS expects
this record under the empty label "@" in the zone's database
(NAMESTORE); however, it will then automatically be copied into each
record set, so that clients never need to do a separate lookup to
discover the NICK record.  Also, users do not usually have to worry
about setting the NICK record: it is automatically set to the local
name of the TLD.

   Example
     Name: @; RRType: NICK; Value: bob

This record in Bob's zone will tell other users that this zone wants to
be referred to as 'bob'. Note that nobody is obliged to call Bob's zone
'bob' in their own zones. It can be seen as a recommendation ("Please
call this zone 'bob'").


File: gnunet.info,  Node: PKEY,  Next: BOX,  Prev: NICK,  Up: Resource Records in GNS

5.6.6.2 PKEY
............

PKEY records are used to add delegation to other users' zones and give
those zones a petname.

   Example  Let Bob's zone be identified by the hash "ABC012". Bob is
your friend so you want to give them the petname "friend". Then you add
the following record to your zone:

     Name: friend; RRType: PKEY; Value: ABC012;

This will allow you to resolve records in bob's zone under
"*.friend.gnu".


File: gnunet.info,  Node: BOX,  Next: LEHO,  Prev: PKEY,  Up: Resource Records in GNS

5.6.6.3 BOX
...........

BOX records are there to integrate information from TLSA or SRV records
under the main label. In DNS, TLSA and SRV records use special names of
the form `_port._proto.(label.)*tld' to indicate the port number and
protocol (i.e. tcp or udp) for which the TLSA or SRV record is valid.
This causes various problems, and is elegantly solved in GNS by
integrating the protocol and port numbers together with the respective
value into a "BOX" record.  Note that in the GUI, you do not get to
edit BOX records directly right now -- the GUI will provide the
illusion of directly editing the TLSA and SRV records, even though they
internally are BOXed up.


File: gnunet.info,  Node: LEHO,  Next: VPN,  Prev: BOX,  Up: Resource Records in GNS

5.6.6.4 LEHO
............

The LEgacy HOstname of a server. Some webservers expect a specific
hostname to provide a service (virtiual hosting). Also SSL certificates
usually contain DNS names. To provide the expected legacy DNS name for
a server, the LEHO record can be used.  To mitigate the just mentioned
issues the GNS proxy has to be used.  The GNS proxy will use the LEHO
information to apply the necessary transformations.


File: gnunet.info,  Node: VPN,  Next: A AAAA and TXT,  Prev: LEHO,  Up: Resource Records in GNS

5.6.6.5 VPN
...........

GNS allows easy access to services provided by the GNUnet Virtual Public
Network. When the GNS resolver encounters a VPN record it will contact
the VPN service to try and allocate an IPv4/v6 address (if the queries
record type is an IP address) that can be used to contact the service.

   Example  I want to provide access to the VPN service "web.gnu." on
port 80 on peer ABC012: Name: www; RRType: VPN; Value: 80 ABC012
web.gnu.

   The peer ABC012 is configured to provide an exit point for the
service "web.gnu." on port 80 to it's server running locally on port
8080 by having the following lines in the `gnunet.conf' configuration
file:

     [web.gnunet.]
     TCP_REDIRECTS = 80:localhost4:8080


File: gnunet.info,  Node: A AAAA and TXT,  Next: CNAME,  Prev: VPN,  Up: Resource Records in GNS

5.6.6.6 A AAAA and TXT
......................

Those records work in exactly the same fashion as in traditional DNS.


File: gnunet.info,  Node: CNAME,  Next: GNS2DNS,  Prev: A AAAA and TXT,  Up: Resource Records in GNS

5.6.6.7 CNAME
.............

As specified in RFC 1035 whenever a CNAME is encountered the query
needs to be restarted with the specified name. In GNS a CNAME can
either be:

   * A zone relative name,

   * A zkey name or

   * A DNS name (in which case resolution will continue outside of GNS
     with the systems DNS resolver)


File: gnunet.info,  Node: GNS2DNS,  Next: SOA SRV PTR and MX,  Prev: CNAME,  Up: Resource Records in GNS

5.6.6.8 GNS2DNS
...............

GNS can delegate authority to a legacy DNS zone. For this, the name of
the DNS nameserver and the name of the DNS zone are specified in a
GNS2DNS record.

   Example

     Name: pet; RRType: GNS2DNS; Value: gnunet.org@a.ns.joker.com

Any query to `pet.gnu' will then be delegated to the DNS server at
`a.ns.joker.com'. For example, `www.pet.gnu (http://www.pet.gnu/)' will
result in a DNS query for `www.gnunet.org (http://www.gnunet.org/)' to
the server at `a.ns.joker.com'. Delegation to DNS via NS records in GNS
can be useful if you do not want to start resolution in the DNS root
zone (due to issues such as censorship or availability).

   Note that you would typically want to use a relative name for the
nameserver, i.e.

     Name: pet; RRType: GNS2DNS; Value: gnunet.org@ns-joker.+
     Name: ns-joker; RRType: A; Value: 184.172.157.218

This way, you can avoid involving the DNS hierarchy in the resolution of
`a.ns.joker.com'. In the example above, the problem may not be obvious
as the nameserver for "gnunet.org" is in the ".com" zone.  However,
imagine the nameserver was "ns.gnunet.org". In this case, delegating to
"ns.gnunet.org" would mean that despite using GNS, censorship in the
DNS ".org" zone would still be effective.


File: gnunet.info,  Node: SOA SRV PTR and MX,  Next: PLACE,  Prev: GNS2DNS,  Up: Resource Records in GNS

5.6.6.9 SOA SRV PTR and MX
..........................

The domain names in those records can, again, be either

   * A zone relative name,

   * A zkey name or

   * A DNS name

   The resolver will expand the zone relative name if possible.  Note
that when using MX records within GNS, the target mail server might
still refuse to accept e-mails to the resulting domain as the name
might not match. GNS-enabled mail clients should use the ZKEY zone as
the destination hostname and GNS-enabled mail servers should be
configured to accept e-mails to the ZKEY-zones of all local users.

   To add a SOA record via the gnunet-namestore command line tool use
the following syntax for the value option. Choose the other options
according to your preference, however in this example we will use a
relative expiry, add the record under the label  and add the records to
the zone bar which already exists:

     $ gnunet-namestore -a -n  -t SOA -z bar -e 3600s -V \
     >    "rname=$PRIMARY_NS \
     >    mname=$CONTACT_MAIL \
     >    $SERIAL,$REFRESH,$RETRY,$EXPIRY,$MINIMUM_TTL"

   The above command filled in with values looks like this:
     $ gnunet-namestore -a -n  -t SOA -z bar -e 3600s -V \
     >    "rname=ns1.bar \
     >    mname=root.bar \
     >    2019081701,3600,1800,86400,7200"

   MX records use a similar syntax which is outlined in the example
below. $SERVER is a domain name as mentioned above.
     $ gnunet-namestore -a -n mail -t MX -z bar -e 3600s -V \
     >    "$PRIORITY,$SERVER"

   With the values substituted this is an example of a working command:
     $ gnunet-namestore -a -n mail -t MX -z bar -e 3600s -V \
     >    "10,mail.bar"


File: gnunet.info,  Node: PLACE,  Next: PHONE,  Prev: SOA SRV PTR and MX,  Up: Resource Records in GNS

5.6.6.10 PLACE
..............

Record type for a social place.


File: gnunet.info,  Node: PHONE,  Next: ID ATTR,  Prev: PLACE,  Up: Resource Records in GNS

5.6.6.11 PHONE
..............

Record type for a phone (of CONVERSATION).


File: gnunet.info,  Node: ID ATTR,  Next: ID TOKEN,  Prev: PHONE,  Up: Resource Records in GNS

5.6.6.12 ID ATTR
................

Record type for identity attributes (of IDENTITY).


File: gnunet.info,  Node: ID TOKEN,  Next: ID TOKEN METADATA,  Prev: ID ATTR,  Up: Resource Records in GNS

5.6.6.13 ID TOKEN
.................

Record type for an identity token (of IDENTITY-TOKEN).


File: gnunet.info,  Node: ID TOKEN METADATA,  Next: CREDENTIAL,  Prev: ID TOKEN,  Up: Resource Records in GNS

5.6.6.14 ID TOKEN METADATA
..........................

Record type for the private metadata of an identity token (of
IDENTITY-TOKEN).


File: gnunet.info,  Node: CREDENTIAL,  Next: POLICY,  Prev: ID TOKEN METADATA,  Up: Resource Records in GNS

5.6.6.15 CREDENTIAL
...................

Record type for credential.


File: gnunet.info,  Node: POLICY,  Next: ATTRIBUTE,  Prev: CREDENTIAL,  Up: Resource Records in GNS

5.6.6.16 POLICY
...............

Record type for policies.


File: gnunet.info,  Node: ATTRIBUTE,  Next: ABE KEY,  Prev: POLICY,  Up: Resource Records in GNS

5.6.6.17 ATTRIBUTE
..................

Record type for reverse lookups.


File: gnunet.info,  Node: ABE KEY,  Next: ABE MASTER,  Prev: ATTRIBUTE,  Up: Resource Records in GNS

5.6.6.18 ABE KEY
................

Record type for ABE records.


File: gnunet.info,  Node: ABE MASTER,  Next: RECLAIM OIDC CLIENT,  Prev: ABE KEY,  Up: Resource Records in GNS

5.6.6.19 ABE MASTER
...................

Record type for ABE master keys.


File: gnunet.info,  Node: RECLAIM OIDC CLIENT,  Next: RECLAIM OIDC REDIRECT,  Prev: ABE MASTER,  Up: Resource Records in GNS

5.6.6.20 RECLAIM OIDC CLIENT
............................

Record type for reclaim OIDC clients.


File: gnunet.info,  Node: RECLAIM OIDC REDIRECT,  Prev: RECLAIM OIDC CLIENT,  Up: Resource Records in GNS

5.6.6.21 RECLAIM OIDC REDIRECT
..............................

Record type for reclaim OIDC redirect URIs.


File: gnunet.info,  Node: Synchronizing with legacy DNS,  Next: Migrating an existing DNS zone into GNS,  Prev: Resource Records in GNS,  Up: The GNU Name System

5.6.7 Synchronizing with legacy DNS
-----------------------------------

If you want to support GNS but the master database for a zone is only
available and maintained in DNS, GNUnet includes the
`gnunet-zoneimport' tool to monitor a DNS zone and automatically import
records into GNS.  Today, the tool does not yet support DNS AF(X)R, as
we initially used it on the ".fr" zone which does not allow us to
perform a DNS zone transfer.  Instead, `gnunet-zoneimport' reads a list
of DNS domain names from `stdin', issues DNS queries for each, converts
the obtained records (if possible) and stores the result in the
namestore.

 [image src="images/gns.jpg" alt="picture of DNS-GNS data flow" ]

   The zonemaster service then takes the records from the namestore,
publishes them into the DHT which makes the result available to the GNS
resolver.  In the GNS configuration, non-local zones can be configured
to be intercepted by specifying ".tld = PUBLICKEY" in the configuration
file in the "[gns]" section.

   Note that the namestore by default also populates the namecache.
This pre-population is cryptographically expensive. Thus, on systems
that only serve to import a large (millions of records) DNS zone and
that do not have a local gns service in use, it is thus advisable to
disable the namecache by setting the option "DISABLE" to "YES" in
section "[namecache]".


File: gnunet.info,  Node: Migrating an existing DNS zone into GNS,  Prev: Synchronizing with legacy DNS,  Up: The GNU Name System

5.6.8 Migrating an existing DNS zone into GNS
---------------------------------------------

Ascension is a tool to migrate existing DNS zones into GNS.

   *Note Migrating existing DNS zones into GNS::, for installation
instructions and further information about Ascension.

   Compared to the gnunet-zoneimport tool it strictly uses AXFR or IXFR
depending on whether or not there exists a SOA record for the zone. If
that is the case it will take the serial as a reference point and
request the zone. The server will either answer the IXFR request with a
correct incremental zone or with the entire zone, which depends on the
server configuration.

   After installing the tool according to the README file you have the
following options:

     Ascension
     Usage:
         ascension <domain> [-d] [-p] [-s] [--minimum-ttl=<ttl>] \
             [--dry-run]
         ascension <domain> <port> [-d] [-p] [-s] \
             [--minimum-ttl=<ttl>] [--dry-run]
         ascension <domain> -n <transferns> [-d] [-p] \
             [-s] [--minimum-ttl=<ttl>] [--dry-run]
         ascension <domain> -n <transferns> <port> [-d] \
             [-p] [-s] [--minimum-ttl=<ttl>] [--dry-run]
         ascension -p | --public
         ascension -d | --debug
         ascension -s | --standalone
         ascension -h | --help
         ascension -v | --version

     Options:
         <domain>              Domain to migrate
         <port>                Port for zone transfer
         <transferns>          DNS Server that does the zone transfer
         --minimum-ttl=<ttl>   Minimum TTL for records to migrate \
             [default: 3600]
         --dry-run             Only try if a zone transfer is allowed
         -p --public           Make records public on the DHT
         -s --standalone       Run ascension once
         -d --debug            Enable debugging
         -h --help         Show this screen.
         -v --version      Show version.

   Before you can migrate any zone though, you need to start a local
GNUnet peer:
     $ gnunet-arm -s

   To migrate the Syrian top level domain - one of the few top level
domains that support zone transfers - into GNS use the following
command:

     $ ascension sy. -n ns1.tld.sy. -p

   The -p flag will tell GNS to put these records on the DHT so that
other users may resolve these records by using the public key of the
zone.

   Once the zone is migrated, Ascension will output a message telling
you, that it will refresh the zone after the time has elapsed.  You can
resolve the names in the zone directly using GNS or if you want to use
it with your browser, check out the GNS manual section. *Note
Configuring the GNU Name System::. To resolve the records from another
system you need the respective zones PKEY. To get the zones public key,
you can run the following command:

     $ gnunet-identity -dqe sy

   Where "sy" is the name of the zone you want to migrate.

   You can share the PKEY of the zone with your friends. They can then
resolve records in the zone by doing a lookup replacing the zone label
with your PKEY:

     $ gnunet-gns -t SOA -u "$PKEY"

   The program will continue to run as a daemon and update once the
refresh time specified in the zones SOA record has elapsed.

   DNSCurve style records are supported in the latest release and they
are added as a PKEY record to be referred to the respective GNS public
key. Key distribution is still a problem but provided someone else has
a public key under a given label it can be looked up.

   There is an unofficial Debian package called python3-ascension that
adds a system user ascension and runs a GNUnet peer in the background.

   Ascension-bind is also an unofficial Debian package that on
installation checks for running DNS zones and whether or not they are
transferable using DNS zone transfer (AXFR). It asks the administrator
which zones to migrate into GNS and installs a systemd unit file to
keep the zone up to date.  If you want to migrate different zones you
might want to check the unit file from the package as a guide.


File: gnunet.info,  Node: reclaimID Identity Provider,  Next: Using the Virtual Public Network,  Prev: The GNU Name System,  Up: Using GNUnet

5.7 reclaimID Identity Provider
===============================

The reclaimID Identity Provider (IdP) is a decentralized IdP service.
It allows its users to manage and authorize third parties to access
their identity attributes such as email or shipping addresses.

   It basically mimics the concepts of centralized IdPs, such as those
offered by Google or Facebook.  Like other IdPs, reclaimID features an
(optional) OpenID-Connect 1.0-compliant protocol layer that can be used
for websites to integrate reclaimID as an Identity Provider with little
effort.

* Menu:

* Managing Attributes::
* Sharing Attributes with Third Parties::
* Revoking Authorizations of Third Parties::
* OpenID Connect::


File: gnunet.info,  Node: Managing Attributes,  Next: Sharing Attributes with Third Parties,  Up: reclaimID Identity Provider

5.7.1 Managing Attributes
-------------------------

Before adding attributes to an identity, you must first create an ego:

     $ gnunet-identity -C "user"

   Henceforth, you can manage a new user profile of the user "user".

   To add an email address to your user profile, simply use the
`gnunet-reclaim' command line tool::

     $ gnunet-reclaim -e "user" -a "email" -V "username@example.gnunet"

   All of your attributes can be listed using the `gnunet-reclaim'
command line tool as well:

     $ gnunet-reclaim -e "user" -D

   Currently, and by default, attribute values are interpreted as plain
text.  In the future there might be more value types such as X.509
certificate credentials.


File: gnunet.info,  Node: Sharing Attributes with Third Parties,  Next: Revoking Authorizations of Third Parties,  Prev: Managing Attributes,  Up: reclaimID Identity Provider

5.7.2 Sharing Attributes with Third Parties
-------------------------------------------

If you want to allow a third party such as a website or friend to
access to your attributes (or a subset thereof) execute:

     $ gnunet-reclaim -e "user" -r "PKEY" -i "attribute1,attribute2,..."

   Where "PKEY" is the public key of the third party and
"attribute1,attribute2,..." is a comma-separated list of attribute
names, such as "email,name,...", that you want to share.

   The command will return a "ticket" string.  You must give this
"ticket" to the requesting third party.

   The third party can then retrieve your shared identity attributes
using:

     $ gnunet-reclaim -e "friend" -C "ticket"

   Where "friend" is the name for "user" that the requesting party is
using.  This will retrieve and list the shared identity attributes.
The above command will also work if the user is currently offline since
the attributes are retrieved from GNS.  Further, the "ticket" can be
re-used later to retrieve up-to-date attributes in case "friend" has
changed the value(s). For instance, because his email address changed.

   To list all given authorizations (tickets) you can execute:
     $ gnunet-reclaim -e "friend" -T (TODO there is only a C and REST API for this at this time)


File: gnunet.info,  Node: Revoking Authorizations of Third Parties,  Next: OpenID Connect,  Prev: Sharing Attributes with Third Parties,  Up: reclaimID Identity Provider

5.7.3 Revoking Authorizations of Third Parties
----------------------------------------------

If you want to revoke the access of a third party to your attributes
you can execute:

     $ gnunet-reclaim -e "user" -R "ticket"

   This will prevent the third party from accessing the attribute in
the future.  Please note that if the third party has previously
accessed the attribute, there is not way in which the system could have
prevented the thiry party from storing the data.  As such, only access
to updated data in the future can be revoked.  This behaviour is
_exactly the same_ as with other IdPs.


File: gnunet.info,  Node: OpenID Connect,  Prev: Revoking Authorizations of Third Parties,  Up: reclaimID Identity Provider

5.7.4 OpenID Connect
--------------------

There is an OpenID Connect API for use with reclaimID.  However, its
use is quite complicated to setup.  As a proof-of-concept, you can look
at https://gitlab.com/reclaimid.

   In the PoC and by convention for reclaimID, the OpenID Connect
Endpoints are found at:

     http://api.reclaim/openid/authorize
     http://api.reclaim/openid/token
     http://api.reclaim/openid/userinfo
     http://api.reclaim/openid/login

   The token endpoint is protected using HTTP basic authentication.
You can authenticate using any username and the password configured
under:

     $ gnunet-config -s reclaim-rest-plugin -o PSW

   The authorize endpoint is protected using a Cookie which can be
obtained through a request against the login endpoint.  This flow is
meant to be used in the context of the OpenID Connect authorization
flow to collect user consent interactively.  Without a Cookie, the
authorize endpoint redirects to a URI configured under:

     $ gnunet-config -s reclaim-rest-plugin -o ADDRESS

   Our PoC includes a user interface (https://gitlab.com/reclaimid)
which integrates this process is an OpenID Connect compatible fashion.

   The token endpoint is protected using OAuth2 and expects the grant
which is retrieved from the authorization endpoint according to the
standard.

   The userinfo endpoint is protected using OAuth2 and expects a bearer
access token which is retrieved from a token request.

   In order to create and register a client you need to execute the
following steps:

     $ gnunet-identity -C <client_name>
     $ gnunet-namestore -z <client_name> -a -n "@" -t RECLAIM_OIDC_REDIRECT -V <redirect_uri> -e 1d -p
     $ gnunet-namestore -z <client_name> -a -n "@" -t RECLAIM_OIDC_CLIENT -V "My OIDC Client" -e 1d -p

   The client_id will be the public key of the client.  As a redirect
URI, you may use any globally unique DNS or GNS URI.  The client
description will be displayed to the user on authorization.

   Any website or relying party must use the endpoint
https://api.reclaim/openid/authorize in its authorization redirects,
e.g.

     <a href="https://api.reclaim/openid/authorize?client_id=<PKEY>\
                                                  &scope=email\
                                                  &redirect_uri=<redirect_uri>\
                                                  &nonce=<random>">Login</a>

   This will direct the user's browser onto his local reclaimID
instance.  After giving consent, you will be provided with the OpenID
Connect authorization code according to the specifications at your
provided redirect URI.  The example code for the PoC website can be
found at https://gitlab.com/reclaimid/demo.


File: gnunet.info,  Node: Using the Virtual Public Network,  Prev: reclaimID Identity Provider,  Up: Using GNUnet

5.8 Using the Virtual Public Network
====================================

* Menu:

* Setting up an Exit node::
* Fedora and the Firewall::
* Setting up VPN node for protocol translation and tunneling::

   Using the GNUnet Virtual Public Network (VPN) application you can
tunnel IP traffic over GNUnet. Moreover, the VPN comes with built-in
protocol translation and DNS-ALG support, enabling IPv4-to-IPv6
protocol translation (in both directions).  This chapter documents how
to use the GNUnet VPN.

   The first thing to note about the GNUnet VPN is that it is a public
network. All participating peers can participate and there is no secret
key to control access. So unlike common virtual private networks, the
GNUnet VPN is not useful as a means to provide a "private" network
abstraction over the Internet. The GNUnet VPN is a virtual network in
the sense that it is an overlay over the Internet, using its own
routing mechanisms and can also use an internal addressing scheme. The
GNUnet VPN is an Internet underlay -- TCP/IP applications run on top of
it.

   The VPN is currently only supported on GNU/Linux systems.  Support
for operating systems that support TUN (such as FreeBSD) should be easy
to add (or might not even require any coding at all -- we just did not
test this so far). Support for other operating systems would require
re-writing the code to create virtual network interfaces and to
intercept DNS requests.

   The VPN does not provide good anonymity. While requests are routed
over the GNUnet network, other peers can directly see the source and
destination of each (encapsulated) IP packet. Finally, if you use the
VPN to access Internet services, the peer sending the request to the
Internet will be able to observe and even alter the IP traffic. We will
discuss additional security implications of using the VPN later in this
chapter.


File: gnunet.info,  Node: Setting up an Exit node,  Next: Fedora and the Firewall,  Up: Using the Virtual Public Network

5.8.1 Setting up an Exit node
-----------------------------

Any useful operation with the VPN requires the existence of an exit
node in the GNUnet Peer-to-Peer network. Exit functionality can only be
enabled on peers that have regular Internet access. If you want to play
around with the VPN or support the network, we encourage you to setup
exit nodes. This chapter documents how to setup an exit node.

   There are four types of exit functions an exit node can provide, and
using the GNUnet VPN to access the Internet will only work nicely if
the first three types are provided somewhere in the network. The four
exit functions are:

   * DNS: allow other peers to use your DNS resolver

   * IPv4: allow other peers to access your IPv4 Internet connection

   * IPv6: allow other peers to access your IPv6 Internet connection

   * Local service: allow other peers to access a specific TCP or UDP
     service your peer is providing

   By enabling "exit" in gnunet-setup and checking the respective boxes
in the "exit" tab, you can easily choose which of the above exit
functions you want to support.

   Note, however, that by supporting the first three functions you will
allow arbitrary other GNUnet users to access the Internet via your
system. This is somewhat similar to running a Tor exit node. The
Torproject has a nice article about what to consider if you want to do
this here. We believe that generally running a DNS exit node is
completely harmless.

   The exit node configuration does currently not allow you to restrict
the Internet traffic that leaves your system. In particular, you cannot
exclude SMTP traffic (or block port 25) or limit to HTTP traffic using
the GNUnet configuration. However, you can use your host firewall to
restrict outbound connections from the virtual tunnel interface. This
is highly recommended. In the future, we plan to offer a wider range of
configuration options for exit nodes.

   Note that by running an exit node GNUnet will configure your kernel
to perform IP-forwarding (for IPv6) and NAT (for IPv4) so that the
traffic from the virtual interface can be routed to the Internet.  In
order to provide an IPv6-exit, you need to have a subnet routed to your
host's external network interface and assign a subrange of that subnet
to the GNUnet exit's TUN interface.

   When running a local service, you should make sure that the local
service is (also) bound to the IP address of your EXIT interface (i.e.
169.254.86.1). It will NOT work if your local service is just bound to
loopback. You may also want to create a "VPN" record in your zone of
the GNU Name System to make it easy for others to access your service
via a name instead of just the full service descriptor. Note that the
identifier you assign the service can serve as a passphrase or shared
secret, clients connecting to the service must somehow learn the
service's name. VPN records in the GNU Name System can make this easier.


File: gnunet.info,  Node: Fedora and the Firewall,  Next: Setting up VPN node for protocol translation and tunneling,  Prev: Setting up an Exit node,  Up: Using the Virtual Public Network

5.8.2 Fedora and the Firewall
-----------------------------

When using an exit node on Fedora 15, the standard firewall can create
trouble even when not really exiting the local system!  For IPv4, the
standard rules seem fine. However, for IPv6 the standard rules prohibit
traffic from the network range of the virtual interface created by the
exit daemon to the local IPv6 address of the same interface (which is
essentially loopback traffic, so you might suspect that a standard
firewall would leave this traffic alone). However, as somehow for IPv6
the traffic is not recognized as originating from the local system (and
as the connection is not already "established"), the firewall drops the
traffic. You should still get ICMPv6 packets back, but that's obviously
not very useful.

   Possible ways to fix this include disabling the firewall (do you
have a good reason for having it on?) or disabling the firewall at
least for the GNUnet exit interface (or the respective IPv4/IPv6
address range). The best way to diagnose these kinds of problems in
general involves setting the firewall to REJECT instead of DROP and to
watch the traffic using wireshark (or tcpdump) to see if ICMP messages
are generated when running some tests that should work.


File: gnunet.info,  Node: Setting up VPN node for protocol translation and tunneling,  Prev: Fedora and the Firewall,  Up: Using the Virtual Public Network

5.8.3 Setting up VPN node for protocol translation and tunneling
----------------------------------------------------------------

The GNUnet VPN/PT subsystem enables you to tunnel IP traffic over the
VPN to an exit node, from where it can then be forwarded to the
Internet. This section documents how to setup VPN/PT on a node.  Note
that you can enable both the VPN and an exit on the same peer.  In this
case, IP traffic from your system may enter your peer's VPN and leave
your peer's exit. This can be useful as a means to do protocol
translation. For example, you might have an application that supports
only IPv4 but needs to access an IPv6-only site. In this case, GNUnet
would perform 4to6 protocol translation between the VPN (IPv4) and the
Exit (IPv6). Similarly, 6to4 protocol translation is also possible.
However, the primary use for GNUnet would be to access an Internet
service running with an IP version that is not supported by your ISP.
In this case, your IP traffic would be routed via GNUnet to a peer that
has access to the Internet with the desired IP version.

   Setting up an entry node into the GNUnet VPN primarily requires you
to enable the "VPN/PT" option in "gnunet-setup". This will launch the
"gnunet-service-vpn", "gnunet-service-dns" and "gnunet-daemon-pt"
processes. The "gnunet-service-vpn" will create a virtual interface
which will be used as the target for your IP traffic that enters the
VPN. Additionally, a second virtual interface will be created by the
"gnunet-service-dns" for your DNS traffic. You will then need to
specify which traffic you want to tunnel over GNUnet. If your ISP only
provides you with IPv4 or IPv6-access, you may choose to tunnel the
other IP protocol over the GNUnet VPN. If you do not have an ISP (and
are connected to other GNUnet peers via WLAN), you can also choose to
tunnel all IP traffic over GNUnet. This might also provide you with
some anonymity. After you enable the respective options and restart
your peer, your Internet traffic should be tunneled over the GNUnet VPN.

   The GNUnet VPN uses DNS-ALG to hijack your IP traffic. Whenever an
application resolves a hostname (i.e. 'gnunet.org'), the
"gnunet-daemon-pt" will instruct the "gnunet-service-dns" to intercept
the request (possibly route it over GNUnet as well) and replace the
normal answer with an IP in the range of the VPN's interface.
"gnunet-daemon-pt" will then tell "gnunet-service-vpn" to forward all
traffic it receives on the TUN interface via the VPN to the original
destination.

   For applications that do not use DNS, you can also manually create
such a mapping using the gnunet-vpn command-line tool. Here, you
specify the desired address family of the result (i.e. "-4"), and the
intended target IP on the Internet ("-i 131.159.74.67") and
"gnunet-vpn" will tell you which IP address in the range of your VPN
tunnel was mapped.

   `gnunet-vpn' can also be used to access "internal" services offered
by GNUnet nodes. So if you happen to know a peer and a service offered
by that peer, you can create an IP tunnel to that peer by specifying
the peer's identity, service name and protocol (-tcp or -udp) and you
will again receive an IP address that will terminate at the respective
peer's service.


File: gnunet.info,  Node: GNUnet Contributors Handbook,  Next: GNUnet Developer Handbook,  Prev: Using GNUnet,  Up: Top

6 GNUnet Contributors Handbook
******************************

* Menu:

* Contributing to GNUnet::
* Licenses of contributions::
* Copyright Assignment::
* Contributing to the Reference Manual::
* Contributing testcases::


File: gnunet.info,  Node: Contributing to GNUnet,  Next: Licenses of contributions,  Up: GNUnet Contributors Handbook

6.1 Contributing to GNUnet
==========================


File: gnunet.info,  Node: Licenses of contributions,  Next: Copyright Assignment,  Prev: Contributing to GNUnet,  Up: GNUnet Contributors Handbook

6.2 Licenses of contributions
=============================

GNUnet is a GNU (https://www.gnu.org/) package.  All code contributions
must thus be put under the GNU Affero Public License (AGPL)
(https://www.gnu.org/licenses/agpl.html).  All documentation should be
put under FSF approved licenses (see fdl
(https://www.gnu.org/copyleft/fdl.html)).

   By submitting documentation, translations, and other content to
GNUnet you automatically grant the right to publish code under the GNU
Public License and documentation under either or both the GNU Public
License or the GNU Free Documentation License.  When contributing to
the GNUnet project, GNU standards and the GNU philosophy
(https://www.gnu.org/philosophy/philosophy.html) should be adhered to.


File: gnunet.info,  Node: Copyright Assignment,  Next: Contributing to the Reference Manual,  Prev: Licenses of contributions,  Up: GNUnet Contributors Handbook

6.3 Copyright Assignment
========================

We require a formal copyright assignment for GNUnet contributors to
GNUnet e.V.; nevertheless, we do allow pseudonymous contributions.  By
signing the copyright agreement and submitting your code (or
documentation) to us, you agree to share the rights to your code with
GNUnet e.V.; GNUnet e.V. receives non-exclusive ownership rights, and
in particular is allowed to dual-license the code. You retain
non-exclusive rights to your contributions, so you can also share your
contributions freely with other projects.

   GNUnet e.V. will publish all accepted contributions under the AGPLv3
or any later version. The association may decide to publish
contributions under additional licenses (dual-licensing).

   We do not intentionally remove your name from your contributions;
however, due to extensive editing it is not always trivial to attribute
contributors properly. If you find that you significantly contributed
to a file (or the project as a whole) and are not listed in the
respective authors file or section, please do let us know.


File: gnunet.info,  Node: Contributing to the Reference Manual,  Next: Contributing testcases,  Prev: Copyright Assignment,  Up: GNUnet Contributors Handbook

6.4 Contributing to the Reference Manual
========================================

   * When writing documentation, please use gender-neutral wording
     (https://en.wikipedia.org/wiki/Singular_they) when referring to
     people, such as singular “they”, “their”, “them”, and
     so forth.

   * Keep line length below 74 characters, except for URLs.  URLs break
     in the PDF output when they contain linebreaks.

   * Do not use tab characters (see chapter 2.1 texinfo manual)

   * Write texts in the third person perspective.



File: gnunet.info,  Node: Contributing testcases,  Prev: Contributing to the Reference Manual,  Up: GNUnet Contributors Handbook

6.5 Contributing testcases
==========================

In the core of gnunet, we restrict new testcases to a small subset of
languages, in order of preference:
  1. C

  2. Portable Shell Scripts

  3. Python (3.7 or later)

   We welcome efforts to remove our existing python-2.7 scripts to
replace them either with portable shell scripts or, at your choice,
python-3.7+.

   If you contribute new python based testcases, we advise you to not
repeat our past misfortunes and write the tests in a standard test
framework like for example pytest.

   For writing portable shell scripts, these tools are useful:
Shellcheck (https://github.com/koalaman/shellcheck), checkbashisms
(https://salsa.debian.org/debian/devscripts/blob/master/scripts/checkbashisms.pl),
`http://www.etalabs.net/sh_tricks.html',
`https://wiki.ubuntu.com/DashAsBinSh', and
`https://mywiki.wooledge.org/Bashism'


File: gnunet.info,  Node: GNUnet Developer Handbook,  Next: GNU Free Documentation License,  Prev: GNUnet Contributors Handbook,  Up: Top

7 GNUnet Developer Handbook
***************************

This book is intended to be an introduction for programmers that want to
extend the GNUnet framework. GNUnet is more than a simple peer-to-peer
application.

   For developers, GNUnet is:

   * developed by a community that believes in the GNU philosophy

   * Free Software (Free as in Freedom), licensed under the GNU Affero
     General Public License
     (`https://www.gnu.org/licenses/licenses.html#AGPL')

   * A set of standards, including coding conventions and architectural
     rules

   * A set of layered protocols, both specifying the communication
     between peers as well as the communication between components of a
     single peer

   * A set of libraries with well-defined APIs suitable for writing
     extensions

   In particular, the architecture specifies that a peer consists of
many processes communicating via protocols. Processes can be written in
almost any language.  `C', `Java' and `Guile' APIs exist for accessing
existing services and for writing extensions.  It is possible to write
extensions in other languages by implementing the necessary IPC
protocols.

   GNUnet can be extended and improved along many possible dimensions,
and anyone interested in Free Software and Freedom-enhancing Networking
is welcome to join the effort. This Developer Handbook attempts to
provide an initial introduction to some of the key design choices and
central components of the system.  This part of the GNUnet
documentation is far from complete, and we welcome informed
contributions, be it in the form of new chapters, sections or
insightful comments.

* Menu:

* Developer Introduction::
* Internal dependencies::
* Code overview::
* System Architecture::
* Subsystem stability::
* Naming conventions and coding style guide::
* Build-system::
* Developing extensions for GNUnet using the gnunet-ext template::
* Writing testcases::
* Building GNUnet and its dependencies::
* TESTING library::
* Performance regression analysis with Gauger::
* TESTBED Subsystem::
* libgnunetutil::
* Automatic Restart Manager (ARM)::
* TRANSPORT Subsystem::
* NAT library::
* Distance-Vector plugin::
* SMTP plugin::
* Bluetooth plugin::
* WLAN plugin::
* ATS Subsystem::
* CORE Subsystem::
* CADET Subsystem::
* NSE Subsystem::
* HOSTLIST Subsystem::
* IDENTITY Subsystem::
* NAMESTORE Subsystem::
* PEERINFO Subsystem::
* PEERSTORE Subsystem::
* SET Subsystem::
* STATISTICS Subsystem::
* Distributed Hash Table (DHT)::
* GNU Name System (GNS)::
* GNS Namecache::
* REVOCATION Subsystem::
* File-sharing (FS) Subsystem::
* REGEX Subsystem::
* REST Subsystem::
* RPS Subsystem::


File: gnunet.info,  Node: Developer Introduction,  Next: Internal dependencies,  Up: GNUnet Developer Handbook

7.1 Developer Introduction
==========================

This Developer Handbook is intended as first introduction to GNUnet for
new developers that want to extend the GNUnet framework. After the
introduction, each of the GNUnet subsystems (directories in the `src/'
tree) is (supposed to be) covered in its own chapter. In addition to
this documentation, GNUnet developers should be aware of the services
available on the GNUnet server to them.

   New developers can have a look a the GNUnet tutorials for C and java
available in the `src/' directory of the repository or under the
following links:

   * *Note Introduction: (gnunet-c-tutorial)Top.

   * GNUnet C tutorial
     (https://docs.gnunet.org/tutorial/gnunet-tutorial.html)

   * GNUnet Java tutorial

   In addition to the GNUnet Reference Documentation you are reading,
the GNUnet server at `https://gnunet.org' contains various resources
for GNUnet developers and those who aspire to become regular
contributors.  They are all conveniently reachable via the "Developer"
entry in the navigation menu. Some additional tools (such as static
analysis reports) require a special developer access to perform certain
operations. If you want (or require) access, you should contact
Christian Grothoff (http://grothoff.org/christian/), GNUnet's
maintainer.

   The public subsystems on the GNUnet server that help developers are:

   * The version control system (git) keeps our code and enables
     distributed development.  It is publicly accessible at
     `https://git.gnunet.org/'.  Only developers with write access can
     commit code, everyone else is encouraged to submit patches to the
     GNUnet-developers mailinglist:
     https://lists.gnu.org/mailman/listinfo/gnunet-developers
     (https://lists.gnu.org/mailman/listinfo/gnunet-developers)

   * The bugtracking system (Mantis).  We use it to track feature
     requests, open bug reports and their resolutions.  It can be
     accessed at https://bugs.gnunet.org/ (https://bugs.gnunet.org/).
     Anyone can report bugs.

   * The current quality of our automated test suite is assessed using
     code coverage analysis. Testcases that improve our code coverage
     are always welcome.

   * We try to automatically find bugs using a static analysis using
     various tools. Note that not everything that is flagged by the
     analysis is a bug, sometimes even good code can be marked as
     possibly problematic. Nevertheless, developers are encouraged to
     at least be aware of all issues in their code that are listed.

   * We use Gauger for automatic performance regression visualization.
     Details on how to use Gauger are here.


* Menu:

* Project overview::


File: gnunet.info,  Node: Project overview,  Up: Developer Introduction

7.1.1 Project overview
----------------------

The GNUnet project consists at this point of several sub-projects. This
section is supposed to give an initial overview about the various
sub-projects. Note that this description also lists projects that are
far from complete, including even those that have literally not a
single line of code in them yet.

   GNUnet sub-projects in order of likely relevance are currently:

`gnunet'
     Core of the P2P framework, including file-sharing, VPN and chat
     applications; this is what the Developer Handbook covers mostly

`gnunet-gtk'
     Gtk+-based user interfaces, including:

        * `gnunet-fs-gtk' (file-sharing),

        * `gnunet-statistics-gtk' (statistics over time),

        * `gnunet-peerinfo-gtk' (information about current connections
          and known peers),

        * `gnunet-namestore-gtk' (GNS record editor),

        * `gnunet-conversation-gtk' (voice chat GUI) and

        * `gnunet-setup' (setup tool for "everything")

`gnunet-fuse'
     Mounting directories shared via GNUnet's file-sharing on GNU/Linux
     distributions

`gnunet-update'
     Installation and update tool

`gnunet-ext'
     Template for starting 'external' GNUnet projects

`gnunet-java'
     Java APIs for writing GNUnet services and applications

`gnunet-java-ext'

`eclectic'
     Code to run GNUnet nodes on testbeds for research, development,
     testing and evaluation

`gnunet-qt'
     Qt-based GNUnet GUI (is it deprecated?)

`gnunet-cocoa'
     cocoa-based GNUnet GUI (is it deprecated?)

`gnunet-guile'
     Guile bindings for GNUnet

`gnunet-python'
     Python bindings for GNUnet


   We are also working on various supporting libraries and tools:

`libextractor'
     GNU libextractor (meta data extraction)

`libmicrohttpd'
     GNU libmicrohttpd (embedded HTTP(S) server library)

`gauger'
     Tool for performance regression analysis

`monkey'
     Tool for automated debugging of distributed systems

`libmwmodem'
     Library for accessing satellite connection quality reports

`libgnurl'
     gnURL (feature-restricted variant of cURL/libcurl)

`www'
     the gnunet.org website (Jinja2 based)

`bibliography'
     Our collected bibliography, papers, references, and so forth

`gnunet-videos-'
     Videos about and around GNUnet activities

   Finally, there are various external projects (see links for a list of
those that have a public website) which build on top of the GNUnet
framework.


File: gnunet.info,  Node: Internal dependencies,  Next: Code overview,  Prev: Developer Introduction,  Up: GNUnet Developer Handbook

7.2 Internal dependencies
=========================

This section tries to give an overview of what processes a typical
GNUnet peer running a particular application would consist of. All of
the processes listed here should be automatically started by
`gnunet-arm -s'.  The list is given as a rough first guide to users for
failure diagnostics.  Ideally, end-users should never have to worry
about these internal dependencies.

   In terms of internal dependencies, a minimum file-sharing system
consists of the following GNUnet processes (in order of dependency):

   * gnunet-service-arm

   * gnunet-service-resolver (required by all)

   * gnunet-service-statistics (required by all)

   * gnunet-service-peerinfo

   * gnunet-service-transport (requires peerinfo)

   * gnunet-service-core (requires transport)

   * gnunet-daemon-hostlist (requires core)

   * gnunet-daemon-topology (requires hostlist, peerinfo)

   * gnunet-service-datastore

   * gnunet-service-dht (requires core)

   * gnunet-service-identity

   * gnunet-service-fs (requires identity, mesh, dht, datastore, core)

A minimum VPN system consists of the following GNUnet processes (in
order of dependency):

   * gnunet-service-arm

   * gnunet-service-resolver (required by all)

   * gnunet-service-statistics (required by all)

   * gnunet-service-peerinfo

   * gnunet-service-transport (requires peerinfo)

   * gnunet-service-core (requires transport)

   * gnunet-daemon-hostlist (requires core)

   * gnunet-service-dht (requires core)

   * gnunet-service-mesh (requires dht, core)

   * gnunet-service-dns (requires dht)

   * gnunet-service-regex (requires dht)

   * gnunet-service-vpn (requires regex, dns, mesh, dht)

A minimum GNS system consists of the following GNUnet processes (in
order of dependency):

   * gnunet-service-arm

   * gnunet-service-resolver (required by all)

   * gnunet-service-statistics (required by all)

   * gnunet-service-peerinfo

   * gnunet-service-transport (requires peerinfo)

   * gnunet-service-core (requires transport)

   * gnunet-daemon-hostlist (requires core)

   * gnunet-service-dht (requires core)

   * gnunet-service-mesh (requires dht, core)

   * gnunet-service-dns (requires dht)

   * gnunet-service-regex (requires dht)

   * gnunet-service-vpn (requires regex, dns, mesh, dht)

   * gnunet-service-identity

   * gnunet-service-namestore (requires identity)

   * gnunet-service-gns (requires vpn, dns, dht, namestore, identity)


File: gnunet.info,  Node: Code overview,  Next: System Architecture,  Prev: Internal dependencies,  Up: GNUnet Developer Handbook

7.3 Code overview
=================

This section gives a brief overview of the GNUnet source code.
Specifically, we sketch the function of each of the subdirectories in
the `gnunet/src/' directory. The order given is roughly bottom-up (in
terms of the layers of the system).

`util/' -- libgnunetutil
     Library with general utility functions, all GNUnet binaries link
     against this library. Anything from memory allocation and data
     structures to cryptography and inter-process communication. The
     goal is to provide an OS-independent interface and more 'secure'
     or convenient implementations of commonly used primitives.  The
     API is spread over more than a dozen headers, developers should
     study those closely to avoid duplicating existing functions.
     *note libgnunetutil::.

`hello/' -- libgnunethello
     HELLO messages are used to describe under which addresses a peer
     can be reached (for example, protocol, IP, port). This library
     manages parsing and generating of HELLO messages.

`block/' -- libgnunetblock
     The DHT and other components of GNUnet store information in units
     called 'blocks'. Each block has a type and the type defines a
     particular format and how that binary format is to be linked to a
     hash code (the key for the DHT and for databases). The block
     library is a wrapper around block plugins which provide the
     necessary functions for each block type.

`statistics/' -- statistics service
     The statistics service enables associating values (of type
     uint64_t) with a component name and a string. The main uses is
     debugging (counting events), performance tracking and user
     entertainment (what did my peer do today?).

`arm/' -- Automatic Restart Manager (ARM)
     The automatic-restart-manager (ARM) service is the GNUnet master
     service. Its role is to start gnunet-services, to re-start them
     when they crashed and finally to shut down the system when
     requested.

`peerinfo/' -- peerinfo service
     The peerinfo service keeps track of which peers are known to the
     local peer and also tracks the validated addresses for each peer
     (in the form of a HELLO message) for each of those peers. The peer
     is not necessarily connected to all peers known to the peerinfo
     service.  Peerinfo provides persistent storage for peer identities
     -- peers are not forgotten just because of a system restart.

`datacache/' -- libgnunetdatacache
     The datacache library provides (temporary) block storage for the
     DHT.  Existing plugins can store blocks in Sqlite, Postgres or
     MySQL databases.  All data stored in the cache is lost when the
     peer is stopped or restarted (datacache uses temporary tables).

`datastore/' -- datastore service
     The datastore service stores file-sharing blocks in databases for
     extended periods of time. In contrast to the datacache, data is
     not lost when peers restart. However, quota restrictions may still
     cause old, expired or low-priority data to be eventually discarded.
     Existing plugins can store blocks in Sqlite, Postgres or MySQL
     databases.

`template/' -- service template
     Template for writing a new service. Does nothing.

`ats/' -- Automatic Transport Selection
     The automatic transport selection (ATS) service is responsible for
     deciding which address (i.e.  which transport plugin) should be
     used for communication with other peers, and at what bandwidth.

`nat/' -- libgnunetnat
     Library that provides basic functions for NAT traversal.  The
     library supports NAT traversal with manual hole-punching by the
     user, UPnP and ICMP-based autonomous NAT traversal. The library
     also includes an API for testing if the current configuration
     works and the `gnunet-nat-server' which provides an external
     service to test the local configuration.

`fragmentation/' -- libgnunetfragmentation
     Some transports (UDP and WLAN, mostly) have restrictions on the
     maximum transfer unit (MTU) for packets. The fragmentation library
     can be used to break larger packets into chunks of at most 1k and
     transmit the resulting fragments reliably (with acknowledgment,
     retransmission, timeouts, etc.).

`transport/' -- transport service
     The transport service is responsible for managing the basic P2P
     communication. It uses plugins to support P2P communication over
     TCP, UDP, HTTP, HTTPS and other protocols.The transport service
     validates peer addresses, enforces bandwidth restrictions, limits
     the total number of connections and enforces connectivity
     restrictions (i.e.  friends-only).

`peerinfo-tool/' -- gnunet-peerinfo
     This directory contains the gnunet-peerinfo binary which can be
     used to inspect the peers and HELLOs known to the peerinfo service.

`core/'
     The core service is responsible for establishing encrypted,
     authenticated connections with other peers, encrypting and
     decrypting messages and forwarding messages to higher-level
     services that are interested in them.

`testing/' -- libgnunettesting
     The testing library allows starting (and stopping) peers for
     writing testcases.  It also supports automatic generation of
     configurations for peers ensuring that the ports and paths are
     disjoint. libgnunettesting is also the foundation for the testbed
     service

`testbed/' -- testbed service
     The testbed service is used for creating small or large scale
     deployments of GNUnet peers for evaluation of protocols.  It
     facilitates peer deployments on multiple hosts (for example, in a
     cluster) and establishing various network topologies (both
     underlay and overlay).

`nse/' -- Network Size Estimation
     The network size estimation (NSE) service implements a protocol
     for (securely) estimating the current size of the P2P network.

`dht/' -- distributed hash table
     The distributed hash table (DHT) service provides a distributed
     implementation of a hash table to store blocks under hash keys in
     the P2P network.

`hostlist/' -- hostlist service
     The hostlist service allows learning about other peers in the
     network by downloading HELLO messages from an HTTP server, can be
     configured to run such an HTTP server and also implements a P2P
     protocol to advertise and automatically learn about other peers
     that offer a public hostlist server.

`topology/' -- topology service
     The topology service is responsible for maintaining the mesh
     topology. It tries to maintain connections to friends (depending
     on the configuration) and also tries to ensure that the peer has a
     decent number of active connections at all times. If necessary, new
     connections are added. All peers should run the topology service,
     otherwise they may end up not being connected to any other peer
     (unless some other service ensures that core establishes the
     required connections). The topology service also tells the
     transport service which connections are permitted (for
     friend-to-friend networking)

`fs/' -- file-sharing
     The file-sharing (FS) service implements GNUnet's file-sharing
     application. Both anonymous file-sharing (using gap) and
     non-anonymous file-sharing (using dht) are supported.

`cadet/' -- cadet service
     The CADET service provides a general-purpose routing abstraction
     to create end-to-end encrypted tunnels in mesh networks. We wrote
     a paper documenting key aspects of the design.

`tun/' -- libgnunettun
     Library for building IPv4, IPv6 packets and creating checksums for
     UDP, TCP and ICMP packets. The header defines C structs for common
     Internet packet formats and in particular structs for interacting
     with TUN (virtual network) interfaces.

`mysql/' -- libgnunetmysql
     Library for creating and executing prepared MySQL statements and
     to manage the connection to the MySQL database.  Essentially a
     lightweight wrapper for the interaction between GNUnet components
     and libmysqlclient.

`dns/'
     Service that allows intercepting and modifying DNS requests of the
     local machine. Currently used for IPv4-IPv6 protocol translation
     (DNS-ALG) as implemented by "pt/" and for the GNUnet naming
     system. The service can also be configured to offer an exit
     service for DNS traffic.

`vpn/' -- VPN service
     The virtual public network (VPN) service provides a virtual tunnel
     interface (VTUN) for IP routing over GNUnet.  Needs some other
     peers to run an "exit" service to work.  Can be activated using
     the "gnunet-vpn" tool or integrated with DNS using the "pt" daemon.

`exit/'
     Daemon to allow traffic from the VPN to exit this peer to the
     Internet or to specific IP-based services of the local peer.
     Currently, an exit service can only be restricted to IPv4 or IPv6,
     not to specific ports and or IP address ranges. If this is not
     acceptable, additional firewall rules must be added manually. exit
     currently only works for normal UDP, TCP and ICMP traffic; DNS
     queries need to leave the system via a DNS service.

`pt/'
     protocol translation daemon. This daemon enables 4-to-6, 6-to-4,
     4-over-6 or 6-over-4 transitions for the local system. It
     essentially uses "DNS" to intercept DNS replies and then maps
     results to those offered by the VPN, which then sends them using
     mesh to some daemon offering an appropriate exit service.

`identity/'
     Management of egos (alter egos) of a user; identities are
     essentially named ECC private keys and used for zones in the GNU
     name system and for namespaces in file-sharing, but might find
     other uses later

`revocation/'
     Key revocation service, can be used to revoke the private key of
     an identity if it has been compromised

`namecache/'
     Cache for resolution results for the GNU name system; data is
     encrypted and can be shared among users, loss of the data should
     ideally only result in a performance degradation (persistence not
     required)

`namestore/'
     Database for the GNU name system with per-user private information,
     persistence required

`gns/'
     GNU name system, a GNU approach to DNS and PKI.

`dv/'
     A plugin for distance-vector (DV)-based routing.  DV consists of a
     service and a transport plugin to provide peers with the illusion
     of a direct P2P connection for connections that use multiple
     (typically up to 3) hops in the actual underlay network.

`regex/'
     Service for the (distributed) evaluation of regular expressions.

`scalarproduct/'
     The scalar product service offers an API to perform a secure
     multiparty computation which calculates a scalar product between
     two peers without exposing the private input vectors of the peers
     to each other.

`consensus/'
     The consensus service will allow a set of peers to agree on a set
     of values via a distributed set union computation.

`rest/'
     The rest API allows access to GNUnet services using RESTful
     interaction.  The services provide plugins that can exposed by the
     rest server.


File: gnunet.info,  Node: System Architecture,  Next: Subsystem stability,  Prev: Code overview,  Up: GNUnet Developer Handbook

7.4 System Architecture
=======================

GNUnet developers like LEGOs. The blocks are indestructible, can be
stacked together to construct complex buildings and it is generally easy
to swap one block for a different one that has the same shape. GNUnet's
architecture is based on LEGOs:

 [image src="images/service_lego_block.png" alt="picture of a LEGO block stack - 3 APIs upon IPC/network protocol provided by a service" ]

   This chapter documents the GNUnet LEGO system, also known as GNUnet's
system architecture.

   The most common GNUnet component is a service. Services offer an API
(or several, depending on what you count as "an API") which is
implemented as a library. The library communicates with the main
process of the service using a service-specific network protocol. The
main process of the service typically doesn't fully provide everything
that is needed -- it has holes to be filled by APIs to other services.

   A special kind of component in GNUnet are user interfaces and
daemons.  Like services, they have holes to be filled by APIs of other
services.  Unlike services, daemons do not implement their own network
protocol and they have no API:

 [image src="images/daemon_lego_block.png" alt="A daemon in GNUnet is a component that does not offer an API for others to build upon" ]

   The GNUnet system provides a range of services, daemons and user
interfaces, which are then combined into a layered GNUnet instance (also
known as a peer).

 [image src="images/service_stack.png" alt="A GNUnet peer consists of many layers of services" ]

   Note that while it is generally possible to swap one service for
another compatible service, there is often only one implementation.
However, during development we often have a "new" version of a service
in parallel with an "old" version. While the "new" version is not
working, developers working on other parts of the service can continue
their development by simply using the "old" service. Alternative design
ideas can also be easily investigated by swapping out individual
components. This is typically achieved by simply changing the name of
the "BINARY" in the respective configuration section.

   Key properties of GNUnet services are that they must be separate
processes and that they must protect themselves by applying tight error
checking against the network protocol they implement (thereby achieving
a certain degree of robustness).

   On the other hand, the APIs are implemented to tolerate failures of
the service, isolating their host process from errors by the service.
If the service process crashes, other services and daemons around it
should not also fail, but instead wait for the service process to be
restarted by ARM.


File: gnunet.info,  Node: Subsystem stability,  Next: Naming conventions and coding style guide,  Prev: System Architecture,  Up: GNUnet Developer Handbook

7.5 Subsystem stability
=======================

This section documents the current stability of the various GNUnet
subsystems. Stability here describes the expected degree of
compatibility with future versions of GNUnet. For each subsystem we
distinguish between compatibility on the P2P network level
(communication protocol between peers), the IPC level (communication
between the service and the service library) and the API level
(stability of the API). P2P compatibility is relevant in terms of which
applications are likely going to be able to communicate with future
versions of the network. IPC communication is relevant for the
implementation of language bindings that re-implement the IPC messages.
Finally, API compatibility is relevant to developers that hope to be
able to avoid changes to applications build on top of the APIs of the
framework.

   The following table summarizes our current view of the stability of
the respective protocols or APIs:

Subsystem      P2P            IPC            C API
------------------------------------------------------------ 
util           n/a            n/a            stable
arm            n/a            stable         stable
ats            n/a            unstable       testing
block          n/a            n/a            stable
cadet          testing        testing        testing
consensus      experimental   experimental   experimental
core           stable         stable         stable
datacache      n/a            n/a            stable
datastore      n/a            stable         stable
dht            stable         stable         stable
dns            stable         stable         stable
dv             testing        testing        n/a
exit           testing        n/a            n/a
fragmentation  stable         n/a            stable
fs             stable         stable         stable
gns            stable         stable         stable
hello          n/a            n/a            testing
hostlist       stable         stable         n/a
identity       stable         stable         n/a
multicast      experimental   experimental   experimental
mysql          stable         n/a            stable
namestore      n/a            stable         stable
nat            n/a            n/a            stable
nse            stable         stable         stable
peerinfo       n/a            stable         stable
psyc           experimental   experimental   experimental
pt             n/a            n/a            n/a
regex          stable         stable         stable
revocation     stable         stable         stable
social         experimental   experimental   experimental
statistics     n/a            stable         stable
testbed        n/a            testing        testing
testing        n/a            n/a            testing
topology       n/a            n/a            n/a
transport      stable         stable         stable
tun            n/a            n/a            stable
vpn            testing        n/a            n/a

   Here is a rough explanation of the values:

`stable'
     No incompatible changes are planned at this time; for IPC/APIs, if
     there are incompatible changes, they will be minor and might only
     require minimal changes to existing code; for P2P, changes will be
     avoided if at all possible for the 0.10.x-series

`testing'
     No incompatible changes are planned at this time, but the code is
     still known to be in flux; so while we have no concrete plans, our
     expectation is that there will still be minor modifications; for
     P2P, changes will likely be extensions that should not break
     existing code

`unstable'
     Changes are planned and will happen; however, they will not be
     totally radical and the result should still resemble what is there
     now; nevertheless, anticipated changes will break protocol/API
     compatibility

`experimental'
     Changes are planned and the result may look nothing like what the
     API/protocol looks like today

`unknown'
     Someone should think about where this subsystem headed

`n/a'
     This subsystem does not have an API/IPC-protocol/P2P-protocol


File: gnunet.info,  Node: Naming conventions and coding style guide,  Next: Build-system,  Prev: Subsystem stability,  Up: GNUnet Developer Handbook

7.6 Naming conventions and coding style guide
=============================================

Here you can find some rules to help you write code for GNUnet.

* Menu:

* Naming conventions::
* Coding style::


File: gnunet.info,  Node: Naming conventions,  Next: Coding style,  Up: Naming conventions and coding style guide

7.6.1 Naming conventions
------------------------

* Menu:

* include files::
* binaries::
* logging::
* configuration::
* exported symbols::
* private (library-internal) symbols (including structs and macros)::
* testcases::
* performance tests::
* src/ directories::


File: gnunet.info,  Node: include files,  Next: binaries,  Up: Naming conventions

7.6.1.1 include files
.....................

   * _lib: library without need for a process

   * _service: library that needs a service process

   * _plugin: plugin definition

   * _protocol: structs used in network protocol

   * exceptions:
        * gnunet_config.h -- generated

        * platform.h -- first included

        * gnunet_common.h -- fundamental routines

        * gnunet_directories.h -- generated

        * gettext.h -- external library


File: gnunet.info,  Node: binaries,  Next: logging,  Prev: include files,  Up: Naming conventions

7.6.1.2 binaries
................

   * gnunet-service-xxx: service process (has listen socket)

   * gnunet-daemon-xxx: daemon process (no listen socket)

   * gnunet-helper-xxx[-yyy]: SUID helper for module xxx

   * gnunet-yyy: command-line tool for end-users

   * libgnunet_plugin_xxx_yyy.so: plugin for API xxx

   * libgnunetxxx.so: library for API xxx


File: gnunet.info,  Node: logging,  Next: configuration,  Prev: binaries,  Up: Naming conventions

7.6.1.3 logging
...............

   * services and daemons use their directory name in
     `GNUNET_log_setup' (i.e. 'core') and log using plain 'GNUNET_log'.

   * command-line tools use their full name in `GNUNET_log_setup' (i.e.
     'gnunet-publish') and log using plain 'GNUNET_log'.

   * service access libraries log using '`GNUNET_log_from'' and use
     '`DIRNAME-api'' for the component (i.e. 'core-api')

   * pure libraries (without associated service) use
     '`GNUNET_log_from'' with the component set to their library name
     (without lib or '`.so''), which should also be their directory
     name (i.e. '`nat'')

   * plugins should use '`GNUNET_log_from'' with the directory name and
     the plugin name combined to produce the component name (i.e.
     'transport-tcp').

   * logging should be unified per-file by defining a `LOG' macro with
     the appropriate arguments, along these lines:

          #define LOG(kind,...)
          GNUNET_log_from (kind, "example-api",__VA_ARGS__)



File: gnunet.info,  Node: configuration,  Next: exported symbols,  Prev: logging,  Up: Naming conventions

7.6.1.4 configuration
.....................

   * paths (that are substituted in all filenames) are in PATHS (have
     as few as possible)

   * all options for a particular module (`src/MODULE') are under
     `[MODULE]'

   * options for a plugin of a module are under `[MODULE-PLUGINNAME]'


File: gnunet.info,  Node: exported symbols,  Next: private (library-internal) symbols (including structs and macros),  Prev: configuration,  Up: Naming conventions

7.6.1.5 exported symbols
........................

   * must start with `GNUNET_modulename_' and be defined in
     `modulename.c'

   * exceptions: those defined in `gnunet_common.h'


File: gnunet.info,  Node: private (library-internal) symbols (including structs and macros),  Next: testcases,  Prev: exported symbols,  Up: Naming conventions

7.6.1.6 private (library-internal) symbols (including structs and macros)
.........................................................................

   * must NOT start with any prefix

   * must not be exported in a way that linkers could use them or other
     libraries might see them via headers; they must be either
     declared/defined in C source files or in headers that are in the
     respective directory under `src/modulename/' and NEVER be declared
     in `src/include/'.


File: gnunet.info,  Node: testcases,  Next: performance tests,  Prev: private (library-internal) symbols (including structs and macros),  Up: Naming conventions

7.6.1.7 testcases
.................

   * must be called `test_module-under-test_case-description.c'

   * "case-description" maybe omitted if there is only one test


File: gnunet.info,  Node: performance tests,  Next: src/ directories,  Prev: testcases,  Up: Naming conventions

7.6.1.8 performance tests
.........................

   * must be called `perf_module-under-test_case-description.c'

   * "case-description" maybe omitted if there is only one performance
     test

   * Must only be run if `HAVE_BENCHMARKS' is satisfied


File: gnunet.info,  Node: src/ directories,  Prev: performance tests,  Up: Naming conventions

7.6.1.9 src/ directories
........................

   * gnunet-NAME: end-user applications (i.e., gnunet-search,
     gnunet-arm)

   * gnunet-service-NAME: service processes with accessor library (i.e.,
     gnunet-service-arm)

   * libgnunetNAME: accessor library (_service.h-header) or standalone
     library (_lib.h-header)

   * gnunet-daemon-NAME: daemon process without accessor library (i.e.,
     gnunet-daemon-hostlist) and no GNUnet management port

   * libgnunet_plugin_DIR_NAME: loadable plugins (i.e.,
     libgnunet_plugin_transport_tcp)


File: gnunet.info,  Node: Coding style,  Prev: Naming conventions,  Up: Naming conventions and coding style guide

7.6.2 Coding style
------------------

   * We follow the GNU Coding Standards (*note The GNU Coding
     Standards: (standards)Top.);

   * Indentation is done with spaces, two per level, no tabs;

   * C99 struct initialization is fine;

   * declare only one variable per line, for example:

     instead of

          int i,j;

     write:

          int i;
          int j;

     This helps keep diffs small and forces developers to think
     precisely about the type of every variable.  Note that `char *' is
     different from `const char*' and `int' is different from `unsigned
     int' or `uint32_t'.  Each variable type should be chosen with care.

   * While `goto' should generally be avoided, having a `goto' to the
     end of a function to a block of clean up statements (free, close,
     etc.) can be acceptable.

   * Conditions should be written with constants on the left (to avoid
     accidental assignment) and with the `true' target being either the
     `error' case or the significantly simpler continuation. For
     example:

          if (0 != stat ("filename,"
                         &sbuf))
          {
            error();
          }
          else
          {
            /* handle normal case here */
          }

     instead of

          if (stat ("filename," &sbuf) == 0) {
            /* handle normal case here */
           } else {
            error();
           }

     If possible, the error clause should be terminated with a `return'
     (or `goto' to some cleanup routine) and in this case, the `else'
     clause should be omitted:

          if (0 != stat ("filename",
                         &sbuf))
          {
            error();
            return;
          }
          /* handle normal case here */

     This serves to avoid deep nesting. The 'constants on the left' rule
     applies to all constants (including. `GNUNET_SCHEDULER_NO_TASK'),
     NULL, and enums). With the two above rules (constants on left,
     errors in 'true' branch), there is only one way to write most
     branches correctly.

   * Combined assignments and tests are allowed if they do not hinder
     code clarity. For example, one can write:

          if (NULL == (value = lookup_function()))
          {
            error();
            return;
          }

   * Use `break' and `continue' wherever possible to avoid deep(er)
     nesting. Thus, we would write:

          next = head;
          while (NULL != (pos = next))
          {
            next = pos->next;
            if (! should_free (pos))
              continue;
            GNUNET_CONTAINER_DLL_remove (head,
                                         tail,
                                         pos);
            GNUNET_free (pos);
          }

     instead of

          next = head; while (NULL != (pos = next)) {
            next = pos->next;
            if (should_free (pos)) {
              /* unnecessary nesting! */
              GNUNET_CONTAINER_DLL_remove (head, tail, pos);
              GNUNET_free (pos);
             }
            }

   * We primarily use `for' and `while' loops.  A `while' loop is used
     if the method for advancing in the loop is not a straightforward
     increment operation. In particular, we use:

          next = head;
          while (NULL != (pos = next))
          {
            next = pos->next;
            if (! should_free (pos))
              continue;
            GNUNET_CONTAINER_DLL_remove (head,
                                         tail,
                                         pos);
            GNUNET_free (pos);
          }

     to free entries in a list (as the iteration changes the structure
     of the list due to the free; the equivalent `for' loop does no
     longer follow the simple `for' paradigm of `for(INIT;TEST;INC)').
     However, for loops that do follow the simple `for' paradigm we do
     use `for', even if it involves linked lists:

          /* simple iteration over a linked list */
          for (pos = head;
               NULL != pos;
               pos = pos->next)
          {
             use (pos);
          }

   * The first argument to all higher-order functions in GNUnet must be
     declared to be of type `void *' and is reserved for a closure. We
     do not use inner functions, as trampolines would conflict with
     setups that use non-executable stacks.  The first statement in a
     higher-order function, which unusually should be part of the
     variable declarations, should assign the `cls' argument to the
     precise expected type. For example:

          int
          callback (void *cls,
                    char *args)
          {
            struct Foo *foo = cls;
            int other_variables;

             /* rest of function */
          }

   * As shown in the example above, after the return type of a function
     there should be a break.  Each parameter should be on a new line.

   * It is good practice to write complex `if' expressions instead of
     using deeply nested `if' statements. However, except for addition
     and multiplication, all operators should use parens. This is fine:

          if ( (1 == foo) ||
               ( (0 == bar) &&
                 (x != y) ) )
            return x;

     However, this is not:

          if (1 == foo)
            return x;
          if (0 == bar && x != y)
            return x;

     Note that splitting the `if' statement above is debatable as the
     `return x' is a very trivial statement. However, once the logic
     after the branch becomes more complicated (and is still
     identical), the "or" formulation should be used for sure.

   * There should be two empty lines between the end of the function and
     the comments describing the following function. There should be a
     single empty line after the initial variable declarations of a
     function. If a function has no local variables, there should be no
     initial empty line. If a long function consists of several complex
     steps, those steps might be separated by an empty line (possibly
     followed by a comment describing the following step). The code
     should not contain empty lines in arbitrary places; if in doubt,
     it is likely better to NOT have an empty line (this way, more code
     will fit on the screen).


File: gnunet.info,  Node: Build-system,  Next: Developing extensions for GNUnet using the gnunet-ext template,  Prev: Naming conventions and coding style guide,  Up: GNUnet Developer Handbook

7.7 Build-system
================

If you have code that is likely not to compile or build rules you might
want to not trigger for most developers, use `if HAVE_EXPERIMENTAL' in
your `Makefile.am'.  Then it is OK to (temporarily) add non-compiling
(or known-to-not-port) code.

   If you want to compile all testcases but NOT run them, run configure
with the `--enable-test-suppression' option.

   If you want to run all testcases, including those that take a while,
run configure with the `--enable-expensive-testcases' option.

   If you want to compile and run benchmarks, run configure with the
`--enable-benchmarks' option.

   If you want to obtain code coverage results, run configure with the
`--enable-coverage' option and run the `coverage.sh' script in the
`contrib/' directory.


File: gnunet.info,  Node: Developing extensions for GNUnet using the gnunet-ext template,  Next: Writing testcases,  Prev: Build-system,  Up: GNUnet Developer Handbook

7.8 Developing extensions for GNUnet using the gnunet-ext template
==================================================================

For developers who want to write extensions for GNUnet we provide the
gnunet-ext template to provide an easy to use skeleton.

   gnunet-ext contains the build environment and template files for the
development of GNUnet services, command line tools, APIs and tests.

   First of all you have to obtain gnunet-ext from git:

     git clone https://git.gnunet.org/gnunet-ext.git

   The next step is to bootstrap and configure it. For configure you
have to provide the path containing GNUnet with
`--with-gnunet=/path/to/gnunet' and the prefix where you want the
install the extension using `--prefix=/path/to/install':

     ./bootstrap
     ./configure --prefix=/path/to/install --with-gnunet=/path/to/gnunet

   When your GNUnet installation is not included in the default linker
search path, you have to add `/path/to/gnunet' to the file
`/etc/ld.so.conf' and run `ldconfig' or your add it to the
environmental variable `LD_LIBRARY_PATH' by using

     export LD_LIBRARY_PATH=/path/to/gnunet/lib


File: gnunet.info,  Node: Writing testcases,  Next: Building GNUnet and its dependencies,  Prev: Developing extensions for GNUnet using the gnunet-ext template,  Up: GNUnet Developer Handbook

7.9 Writing testcases
=====================

Ideally, any non-trivial GNUnet code should be covered by automated
testcases. Testcases should reside in the same place as the code that is
being tested. The name of source files implementing tests should begin
with `test_' followed by the name of the file that contains the code
that is being tested.

   Testcases in GNUnet should be integrated with the autotools build
system.  This way, developers and anyone building binary packages will
be able to run all testcases simply by running `make check'. The final
testcases shipped with the distribution should output at most some brief
progress information and not display debug messages by default. The
success or failure of a testcase must be indicated by returning zero
(success) or non-zero (failure) from the main method of the testcase.
The integration with the autotools is relatively straightforward and
only requires modifications to the `Makefile.am' in the directory
containing the testcase. For a testcase testing the code in `foo.c' the
`Makefile.am' would contain the following lines:

     check_PROGRAMS = test_foo
     TESTS = $(check_PROGRAMS)
     test_foo_SOURCES = test_foo.c
     test_foo_LDADD = $(top_builddir)/src/util/libgnunetutil.la

   Naturally, other libraries used by the testcase may be specified in
the `LDADD' directive as necessary.

   Often testcases depend on additional input files, such as a
configuration file. These support files have to be listed using the
`EXTRA_DIST' directive in order to ensure that they are included in the
distribution.

   Example:

     EXTRA_DIST = test_foo_data.conf

   Executing `make check' will run all testcases in the current
directory and all subdirectories. Testcases can be compiled individually
by running `make test_foo' and then invoked directly using
`./test_foo'. Note that due to the use of plugins in GNUnet, it is
typically necessary to run `make install' before running any testcases.
Thus the canonical command `make check install' has to be changed to
`make install check' for GNUnet.


File: gnunet.info,  Node: Building GNUnet and its dependencies,  Next: TESTING library,  Prev: Writing testcases,  Up: GNUnet Developer Handbook

7.10 Building GNUnet and its dependencies
=========================================

In the following section we will outline how to build GNUnet and some
of its dependencies. We will assume a fair amount of knowledge for
building applications under UNIX-like systems. Furthermore we assume
that the build environment is sane and that you are aware of any
implications actions in this process could have.  Instructions here can
be seen as notes for developers (an extension to the 'HACKING' section
in README) as well as package maintainers.  Users should rely on the
available binary packages.  We will use Debian as an example Operating
System environment. Substitute accordingly with your own Operating
System environment.

   For the full list of dependencies, consult the appropriate,
up-to-date section in the `README' file.

   First, we need to build or install (depending on your OS) the
following packages. If you build them from source, build them in this
exact order:

     libgpgerror, libgcrypt, libnettle, libunbound, GnuTLS (with libunbound
     support)

   After we have build and installed those packages, we continue with
packages closer to GNUnet in this step: libgnurl (our libcurl fork),
GNU libmicrohttpd, and GNU libextractor. Again, if your package manager
provides one of these packages, use the packages provided from it
unless you have good reasons (package version too old, conflicts, etc).
We advise against compiling widely used packages such as GnuTLS
yourself if your OS provides a variant already unless you take care of
maintenance of the packages then.

   In the optimistic case, this command will give you all the
dependencies on Debian, Debian derived systems or any Linux Operating
System using the apt package manager:

     sudo apt-get install libgnurl libmicrohttpd libextractor

   From experience we know that at the very least libgnurl is not
available in some environments. You could substitute libgnurl with
libcurl, but we recommend to install libgnurl, as it gives you a
predefined libcurl with the small set GNUnet requires.  libgnurl has
been developed to co-exist with libcurl installations, installing it
will cause no filename or namespace collisions.

   GNUnet and some of its function depend on a limited subset of
cURL/libcurl.  Rather than trying to enforce a certain configuration on
the world, we opted to maintain a microfork of it that ensures that we
can link against the right set of features.  We called this specialized
set of libcurl "libgnurl".  It is fully ABI compatible with libcurl and
currently used by GNUnet and some of its dependencies.

   We download libgnurl and its digital signature from the GNU
fileserver, assuming `TMPDIR' exists.

     Note: TMPDIR might be `/tmp', `TMPDIR', `TMP' or any other
     location. For consistency we assume `TMPDIR' points to `/tmp' for
     the remainder of this section.

     cd \$TMPDIR
     wget https://ftp.gnu.org/gnu/gnunet/gnurl-7.65.3.tar.Z
     wget https://ftp.gnu.org/gnu/gnunet/gnurl-7.65.3.tar.Z.sig

   Next, verify the digital signature of the file:

     gpg --verify gnurl-7.65.3.tar.Z.sig

   If gpg fails, you might try with `gpg2' on your OS. If the error
states that "the key can not be found" or it is unknown, you have to
retrieve the key (A88C8ADD129828D7EAC02E52E22F9BBFEE348588) from a
keyserver first:

     gpg --keyserver pgp.mit.edu --recv-keys A88C8ADD129828D7EAC02E52E22F9BBFEE348588

   or

     gpg --keyserver hkps://keys.openpgp.org --recv-keys A88C8ADD129828D7EAC02E52E22F9BBFEE348588

   and rerun the verification command.

   libgnurl will require the following packages to be present at
runtime: GnuTLS (with DANE support / libunbound), libidn, zlib and at
compile time: libtool, perl, pkg-config, and (for tests) python (2.7, or
any version of python 3).

   Once you have verified that all the required packages are present on
your system, we can proceed to compile libgnurl. This assumes you will
install gnurl in the default location as prefix. To change this, pass
-prefix= to the configure-gnurl script (which is a simple wrapper
around configure).

     tar -xvf gnurl-7.65.3.tar.Z
     cd gnurl-7.65.3
     sh ./configure-gnurl
     make
     make -C tests test
     sudo make install

   After you've compiled and installed libgnurl, we can proceed to
building GNUnet.

   First, in addition to the GNUnet sources you might require
downloading the latest version of various dependencies, depending on
how recent the software versions in your distribution of GNU/Linux are.
Most distributions do not include sufficiently recent versions of these
dependencies.  Thus, a typically installation on a "modern" GNU/Linux
distribution requires you to install the following dependencies
(ideally in this order):

   * libgpgerror and libgcrypt

   * libnettle and libunbound (possibly from distribution), GnuTLS

   * libgnurl (read the README)

   * GNU libmicrohttpd

   * GNU libextractor

   Make sure to first install the various mandatory and optional
dependencies including development headers from your distribution.

   Other dependencies that you should strongly consider to install is a
database (MySQL, SQLite3 or Postgres).  The following instructions will
assume that you installed at least SQLite3 (commonly distributed as
"sqlite" or "sqlite3").  For most distributions you should be able to
find pre-build packages for the database. Again, make sure to install
the client libraries and the respective development headers (if they
are packaged separately) as well.

   You can find specific, detailed instructions for installing of the
dependencies (and possibly the rest of the GNUnet installation) in the
platform-specific descriptions, which can be found in the Index.
Please consult them now.  If your distribution is not listed, please
study the build instructions for Debian stable, carefully as you try to
install the dependencies for your own distribution.  Contributing
additional instructions for further platforms is always appreciated.
Please take in mind that operating system development tends to move at
a rather fast speed. Due to this you should be aware that some of the
instructions could be outdated by the time you are reading this.  If
you find a mistake, please tell us about it (or even better: send a
patch to the documentation to fix it!).

   Before proceeding further, please double-check the dependency list.
Note that in addition to satisfying the dependencies, you might have to
make sure that development headers for the various libraries are also
installed.  There maybe files for other distributions, or you might be
able to find equivalent packages for your distribution.

   While it is possible to build and install GNUnet without having root
access, we will assume that you have full control over your system in
these instructions.  First, you should create a system user _gnunet_
and an additional group _gnunetdns_. On the GNU/Linux distributions
Debian and Ubuntu, type:

     sudo adduser --system --home /var/lib/gnunet --group \
     --disabled-password gnunet
     sudo addgroup --system gnunetdns

On other Unix-like systems, this should have the same effect:

     sudo useradd --system --groups gnunet --home-dir /var/lib/gnunet
     sudo addgroup --system gnunetdns

   Now compile and install GNUnet using:

     tar xvf gnunet-0.12.0.tar.gz
     cd gnunet-0.12.0
     ./configure --with-sudo=sudo --with-nssdir=/lib
     make
     sudo make install

   If you want to be able to enable DEBUG-level log messages, add
`--enable-logging=verbose' to the end of the `./configure' command.
`DEBUG'-level log messages are in English only and should only be
useful for developers (or for filing really detailed bug reports).

Next, edit the file `/etc/gnunet.conf' to contain the following:

     [arm]
     START_SYSTEM_SERVICES = YES
     START_USER_SERVICES = NO

You may need to update your `ld.so' cache to include files installed in
`/usr/local/lib':

     # ldconfig

Then, switch from user `root' to user `gnunet' to start the peer:

     # su -s /bin/sh - gnunet
     $ gnunet-arm -c /etc/gnunet.conf -s

   You may also want to add the last line in the gnunet user's `crontab'
prefixed with `@reboot' so that it is executed whenever the system is
booted:

     @reboot /usr/local/bin/gnunet-arm -c /etc/gnunet.conf -s

This will only start the system-wide GNUnet services.  Type `exit' to
get back your root shell.  Now, you need to configure the per-user
part. For each user that should get access to GNUnet on the system, run
(replace alice with your username):

     sudo adduser alice gnunet

to allow them to access the system-wide GNUnet services. Then, each
user should create a configuration file `~/.config/gnunet.conf' with
the lines:

     [arm]
     START_SYSTEM_SERVICES = NO
     START_USER_SERVICES = YES
     DEFAULTSERVICES = gns

and start the per-user services using

     $ gnunet-arm -c ~/.config/gnunet.conf -s

Again, adding a `crontab' entry to autostart the peer is advised:

     @reboot /usr/local/bin/gnunet-arm -c $HOME/.config/gnunet.conf -s

Note that some GNUnet services (such as socks5 proxies) may need a
system-wide TCP port for each user.  For those services, systems with
more than one user may require each user to specify a different port
number in their personal configuration file.

   Finally, the user should perform the basic initial setup for the GNU
Name System (GNS) certificate authority. This is done by running:

     $ gnunet-gns-proxy-setup-ca

The first generates the default zones, whereas the second setups the GNS
Certificate Authority with the user's browser. Now, to activate GNS in
the normal DNS resolution process, you need to edit your
`/etc/nsswitch.conf' where you should find a line like this:

     hosts: files mdns4_minimal [NOTFOUND=return] dns mdns4

The exact details may differ a bit, which is fine. Add the text _"gns
[NOTFOUND=return]"_ after _"files"_.  Keep in mind that we included a
backslash ("\") here just for markup reasons. You should write the text
below on one line and without the "\":

     hosts: files gns [NOTFOUND=return] mdns4_minimal \
     [NOTFOUND=return] dns mdns4

   You might want to make sure that `/lib/libnss_gns.so.2' exists on
your system, it should have been created during the installation.


File: gnunet.info,  Node: TESTING library,  Next: Performance regression analysis with Gauger,  Prev: Building GNUnet and its dependencies,  Up: GNUnet Developer Handbook

7.11 TESTING library
====================

The TESTING library is used for writing testcases which involve
starting a single or multiple peers. While peers can also be started by
testcases using the ARM subsystem, using TESTING library provides an
elegant way to do this. The configurations of the peers are
auto-generated from a given template to have non-conflicting port
numbers ensuring that peers' services do not run into bind errors. This
is achieved by testing ports' availability by binding a listening
socket to them before allocating them to services in the generated
configurations.

   An another advantage while using TESTING is that it shortens the
testcase startup time as the hostkeys for peers are copied from a
pre-computed set of hostkeys instead of generating them at peer startup
which may take a considerable amount of time when starting multiple
peers or on an embedded processor.

   TESTING also allows for certain services to be shared among peers.
This feature is invaluable when testing with multiple peers as it helps
to reduce the number of services run per each peer and hence the total
number of processes run per testcase.

   TESTING library only handles creating, starting and stopping peers.
Features useful for testcases such as connecting peers in a topology are
not available in TESTING but are available in the TESTBED subsystem.
Furthermore, TESTING only creates peers on the localhost, however by
using TESTBED testcases can benefit from creating peers across multiple
hosts.

* Menu:

* API::
* Finer control over peer stop::
* Helper functions::
* Testing with multiple processes::


File: gnunet.info,  Node: API,  Next: Finer control over peer stop,  Up: TESTING library

7.11.1 API
----------

TESTING abstracts a group of peers as a TESTING system. All peers in a
system have common hostname and no two services of these peers have a
same port or a UNIX domain socket path.

   TESTING system can be created with the function
`GNUNET_TESTING_system_create()' which returns a handle to the system.
This function takes a directory path which is used for generating the
configurations of peers, an IP address from which connections to the
peers' services should be allowed, the hostname to be used in peers'
configuration, and an array of shared service specifications of type
`struct GNUNET_TESTING_SharedService'.

   The shared service specification must specify the name of the
service to share, the configuration pertaining to that shared service
and the maximum number of peers that are allowed to share a single
instance of the shared service.

   TESTING system created with `GNUNET_TESTING_system_create()' chooses
ports from the default range `12000' - `56000' while auto-generating
configurations for peers.  This range can be customised with the
function `GNUNET_TESTING_system_create_with_portrange()'. This function
is similar to `GNUNET_TESTING_system_create()' except that it take 2
additional parameters -- the start and end of the port range to use.

   A TESTING system is destroyed with the function
`GNUNET_TESTING_system_destory()'. This function takes the handle of
the system and a flag to remove the files created in the directory used
to generate configurations.

   A peer is created with the function
`GNUNET_TESTING_peer_configure()'. This functions takes the system
handle, a configuration template from which the configuration for the
peer is auto-generated and the index from where the hostkey for the
peer has to be copied from. When successful, this function returns a
handle to the peer which can be used to start and stop it and to obtain
the identity of the peer. If unsuccessful, a NULL pointer is returned
with an error message. This function handles the generated
configuration to have non-conflicting ports and paths.

   Peers can be started and stopped by calling the functions
`GNUNET_TESTING_peer_start()' and `GNUNET_TESTING_peer_stop()'
respectively. A peer can be destroyed by calling the function
`GNUNET_TESTING_peer_destroy'. When a peer is destroyed, the ports and
paths in allocated in its configuration are reclaimed for usage in new
peers.


File: gnunet.info,  Node: Finer control over peer stop,  Next: Helper functions,  Prev: API,  Up: TESTING library

7.11.2 Finer control over peer stop
-----------------------------------

Using `GNUNET_TESTING_peer_stop()' is normally fine for testcases.
However, calling this function for each peer is inefficient when trying
to shutdown multiple peers as this function sends the termination
signal to the given peer process and waits for it to terminate. It
would be faster in this case to send the termination signals to the
peers first and then wait on them. This is accomplished by the functions
`GNUNET_TESTING_peer_kill()' which sends a termination signal to the
peer, and the function `GNUNET_TESTING_peer_wait()' which waits on the
peer.

   Further finer control can be achieved by choosing to stop a peer
asynchronously with the function `GNUNET_TESTING_peer_stop_async()'.
This function takes a callback parameter and a closure for it in
addition to the handle to the peer to stop. The callback function is
called with the given closure when the peer is stopped. Using this
function eliminates blocking while waiting for the peer to terminate.

   An asynchronous peer stop can be canceled by calling the function
`GNUNET_TESTING_peer_stop_async_cancel()'. Note that calling this
function does not prevent the peer from terminating if the termination
signal has already been sent to it. It does, however, cancels the
callback to be called when the peer is stopped.


File: gnunet.info,  Node: Helper functions,  Next: Testing with multiple processes,  Prev: Finer control over peer stop,  Up: TESTING library

7.11.3 Helper functions
-----------------------

Most of the testcases can benefit from an abstraction which configures a
peer and starts it. This is provided by the function
`GNUNET_TESTING_peer_run()'. This function takes the testing directory
pathname, a configuration template, a callback and its closure.  This
function creates a peer in the given testing directory by using the
configuration template, starts the peer and calls the given callback
with the given closure.

   The function `GNUNET_TESTING_peer_run()' starts the ARM service of
the peer which starts the rest of the configured services. A similar
function `GNUNET_TESTING_service_run' can be used to just start a
single service of a peer. In this case, the peer's ARM service is not
started; instead, only the given service is run.


File: gnunet.info,  Node: Testing with multiple processes,  Prev: Helper functions,  Up: TESTING library

7.11.4 Testing with multiple processes
--------------------------------------

When testing GNUnet, the splitting of the code into a services and
clients often complicates testing. The solution to this is to have the
testcase fork `gnunet-service-arm', ask it to start the required server
and daemon processes and then execute appropriate client actions (to
test the client APIs or the core module or both). If necessary,
multiple ARM services can be forked using different ports (!) to
simulate a network.  However, most of the time only one ARM process is
needed. Note that on exit, the testcase should shutdown ARM with a
`TERM' signal (to give it the chance to cleanly stop its child
processes).

   The following code illustrates spawning and killing an ARM process
from a testcase:

     static void run (void *cls,
                      char *const *args,
                      const char *cfgfile,
                      const struct GNUNET_CONFIGURATION_Handle *cfg) {
       struct GNUNET_OS_Process *arm_pid;
       arm_pid = GNUNET_OS_start_process (NULL,
                                          NULL,
                                          "gnunet-service-arm",
                                          "gnunet-service-arm",
                                          "-c",
                                          cfgname,
                                          NULL);
       /* do real test work here */
       if (0 != GNUNET_OS_process_kill (arm_pid, SIGTERM))
         GNUNET_log_strerror
           (GNUNET_ERROR_TYPE_WARNING, "kill");
       GNUNET_assert (GNUNET_OK == GNUNET_OS_process_wait (arm_pid));
       GNUNET_OS_process_close (arm_pid); }

     GNUNET_PROGRAM_run (argc, argv,
                         "NAME-OF-TEST",
                         "nohelp",
                         options,
                         &run,
                         cls);

   An alternative way that works well to test plugins is to implement a
mock-version of the environment that the plugin expects and then to
simply load the plugin directly.


File: gnunet.info,  Node: Performance regression analysis with Gauger,  Next: TESTBED Subsystem,  Prev: TESTING library,  Up: GNUnet Developer Handbook

7.12 Performance regression analysis with Gauger
================================================

To help avoid performance regressions, GNUnet uses Gauger. Gauger is a
simple logging tool that allows remote hosts to send performance data to
a central server, where this data can be analyzed and visualized. Gauger
shows graphs of the repository revisions and the performance data
recorded for each revision, so sudden performance peaks or drops can be
identified and linked to a specific revision number.

   In the case of GNUnet, the buildbots log the performance data
obtained during the tests after each build. The data can be accessed on
GNUnet's Gauger page.

   The menu on the left allows to select either the results of just one
build bot (under "Hosts") or review the data from all hosts for a given
test result (under "Metrics"). In case of very different absolute value
of the results, for instance arm vs. amd64 machines, the option
"Normalize" on a metric view can help to get an idea about the
performance evolution across all hosts.

   Using Gauger in GNUnet and having the performance of a module
tracked over time is very easy. First of course, the testcase must
generate some consistent metric, which makes sense to have logged.
Highly volatile or random dependent metrics probably are not ideal
candidates for meaningful regression detection.

   To start logging any value, just include `gauger.h' in your testcase
code. Then, use the macro `GAUGER()' to make the Buildbots log whatever
value is of interest for you to `gnunet.org''s Gauger server. No setup
is necessary as most Buildbots have already everything in place and new
metrics are created on demand. To delete a metric, you need to contact
a member of the GNUnet development team (a file will need to be removed
manually from the respective directory).

   The code in the test should look like this:

     [other includes]
     #include <gauger.h>

     int main (int argc, char *argv[]) {

       [run test, generate data]
         GAUGER("YOUR_MODULE",
                "METRIC_NAME",
                (float)value,
                "UNIT"); }

   Where:

*YOUR_MODULE* is a category in the gauger page and should be
     the name of the module or subsystem like "Core" or "DHT"

*METRIC* is
     the name of the metric being collected and should be concise and
     descriptive, like "PUT operations in sqlite-datastore".

*value* is the value
     of the metric that is logged for this run.

*UNIT* is the unit in
     which the value is measured, for instance "kb/s" or "kb of
     RAM/node".

   If you wish to use Gauger for your own project, you can grab a copy
of the latest stable release or check out Gauger's Subversion
repository.

